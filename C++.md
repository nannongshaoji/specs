#C++语言编程规范  
------------------------------------------------
<!-- TOC -->

- [C++语言编程规范](#c语言编程规范)
    - [1 规范制定说明](#1-规范制定说明)
        - [1.1 前言](#11-前言)
        - [1.2 代码总体原则](#12-代码总体原则)
        - [1.3 规范实施解释](#13-规范实施解释)
        - [1.4 术语](#14-术语)
    - [2 头文件](#2-头文件)
        - [2.1 原则](#21-原则)
            - [2.1.1 头文件中适合放置接口的声明，不适合放置实现](#211-头文件中适合放置接口的声明不适合放置实现)
            - [2.1.2 头文件应当职责单一](#212-头文件应当职责单一)
            - [2.1.3 头文件应向稳定的方向包含](#213-头文件应向稳定的方向包含)
        - [2.2 规则](#22-规则)
            - [2.2.1 Self-contained 头文件](#221-self-contained-头文件)
            - [2.2.2 #define 保护](#222-define-保护)
            - [2.2.3 前置声明](#223-前置声明)
            - [2.2.4 #include 的路径及顺序](#224-include-的路径及顺序)
            - [2.2.5 禁止包含用不到的头文件](#225-禁止包含用不到的头文件)
            - [2.2.6 禁止在.cpp文件中通过extern的方式使用外部函数接口、变量](#226-禁止在cpp文件中通过extern的方式使用外部函数接口变量)
            - [2.2.7 禁止在extern "C"中包含头文件](#227-禁止在extern-c中包含头文件)
        - [2.3 编码建议](#23-编码建议)
            - [2.3.1 一个模块通常包含多个.cpp文件，建议放在同一个目录下，目录名即为模块名。为方便外部使用者，建议每一个模块提供一个.h，文件名为目录名](#231-一个模块通常包含多个cpp文件建议放在同一个目录下目录名即为模块名为方便外部使用者建议每一个模块提供一个h文件名为目录名)
            - [2.3.2 如果一个模块包含多个子模块，则建议每一个子模块提供一个对外的.h，文件名为子模块名](#232-如果一个模块包含多个子模块则建议每一个子模块提供一个对外的h文件名为子模块名)
            - [2.3.3 头文件不要使用非习惯用法的扩展名，如.inc](#233-头文件不要使用非习惯用法的扩展名如inc)
    - [3 常量](#3-常量)
        - [3.1 规则](#31-规则)
            - [3.1.1 使用const常量取代宏](#311-使用const常量取代宏)
        - [3.1.2 一组相关的整型常量应定义为枚举](#312-一组相关的整型常量应定义为枚举)
            - [3.1.3 不相关的常量，即使取值一样，也必须分别定义](#313-不相关的常量即使取值一样也必须分别定义)
            - [3.1.4 尽可能使用const](#314-尽可能使用const)
    - [4 变量](#4-变量)
        - [4.1 原则](#41-原则)
            - [4.1.1 一个变量只有一个功能，不能把一个变量用作多种用途](#411-一个变量只有一个功能不能把一个变量用作多种用途)
            - [4.1.2 结构功能单一；不要设计面面俱到的数据结构](#412-结构功能单一不要设计面面俱到的数据结构)
            - [4.1.3 不用或者少用全局变量](#413-不用或者少用全局变量)
        - [4.2 原则](#42-原则)
            - [4.2.1 防止局部变量与全局变量同名](#421-防止局部变量与全局变量同名)
            - [4.2.2 通讯过程中使用的结构，必须注意字节序](#422-通讯过程中使用的结构必须注意字节序)
            - [4.2.3 严禁使用未经初始化的变量作为右值](#423-严禁使用未经初始化的变量作为右值)
            - [4.2.4 禁止定义静态储存周期非POD变量，禁止使用含有副作用的函数初始化POD全局变量](#424-禁止定义静态储存周期非pod变量禁止使用含有副作用的函数初始化pod全局变量)
        - [4.3 编码建议](#43-编码建议)
            - [4.3.1 构造仅有一个模块或函数可以修改、创建，而其余有关模块或函数只访问的全局变量，防止多个不同模块或函数都可以修改、创建同一全局变量的现象](#431-构造仅有一个模块或函数可以修改创建而其余有关模块或函数只访问的全局变量防止多个不同模块或函数都可以修改创建同一全局变量的现象)
            - [4.3.2 使用面向接口编程思想，通过API访问数据：如果本模块的数据需要对外部模块开放，应提供接口函数来设置、获取，同时注意全局数据的访问互斥](#432-使用面向接口编程思想通过api访问数据如果本模块的数据需要对外部模块开放应提供接口函数来设置获取同时注意全局数据的访问互斥)
            - [4.3.3 在首次使用前初始化变量，初始化的地方离使用的地方越近越好，作用域越小越好](#433-在首次使用前初始化变量初始化的地方离使用的地方越近越好作用域越小越好)
            - [4.3.4 尽量减少没有必要的数据类型默认转换与强制转换](#434-尽量减少没有必要的数据类型默认转换与强制转换)
    - [5 表达式](#5-表达式)
        - [5.1 规则](#51-规则)
            - [5.1.1 表达式的值在标准所允许的任何运算次序下都应该是相同的](#511-表达式的值在标准所允许的任何运算次序下都应该是相同的)
        - [5.2 编码建议](#52-编码建议)
            - [5.2.1 函数调用不要作为另一个函数的参数使用，否则对于代码的调试、阅读都不利](#521-函数调用不要作为另一个函数的参数使用否则对于代码的调试阅读都不利)
            - [5.2.2 赋值语句不要写在if等语句中，或者作为函数的参数使用](#522-赋值语句不要写在if等语句中或者作为函数的参数使用)
            - [5.2.3 用括号明确表达式的操作顺序，避免过分依赖默认优先级](#523-用括号明确表达式的操作顺序避免过分依赖默认优先级)
            - [5.2.4 赋值操作符不能使用在产生布尔值的表达式上](#524-赋值操作符不能使用在产生布尔值的表达式上)
    - [6 作用域](#6-作用域)
        - [6.1 原则](#61-原则)
            - [6.1.1 使用命名空间归类](#611-使用命名空间归类)
        - [6.2 规则](#62-规则)
            - [6.2.1 不要在头文件中或者#include之前使用using指示符](#621-不要在头文件中或者include之前使用using指示符)
        - [6.3 编码建议](#63-编码建议)
            - [6.3.1 尽量少使用嵌套类](#631-尽量少使用嵌套类)
            - [6.3.2 尽可能不使用局部类](#632-尽可能不使用局部类)
            - [6.3.3 使用静态成员函数或名字空间内的非成员函数，避免使用全局函数](#633-使用静态成员函数或名字空间内的非成员函数避免使用全局函数)
    - [7 函数](#7-函数)
        - [7.1 规则](#71-规则)
            - [7.1.1 禁止用memcpy、memset初始化非POD对象](#711-禁止用memcpymemset初始化非pod对象)
            - [7.1.2 使用C++风格的类型转换，不要使用C风格的类型转换](#712-使用c风格的类型转换不要使用c风格的类型转换)
        - [7.2 编码建议](#72-编码建议)
            - [7.2.1 变量使用时才声明并初始化](#721-变量使用时才声明并初始化)
            - [7.2.2 避免构造函数做复杂的初始化，可以使用“init”函数](#722-避免构造函数做复杂的初始化可以使用init函数)
            - [7.2.3 初始化列表要严格按照成员声明顺序来初始化它们](#723-初始化列表要严格按照成员声明顺序来初始化它们)
            - [7.2.4 明确有外部依赖关系的全局与静态对象的初始化顺序](#724-明确有外部依赖关系的全局与静态对象的初始化顺序)
            - [7.2.5 避免使用reinterpret_cast](#725-避免使用reinterpret_cast)
            - [7.2.6 避免使用const_cast](#726-避免使用const_cast)
            - [7.2.7 使用虚函数替换dynamic_cast](#727-使用虚函数替换dynamic_cast)
    - [8 函数](#8-函数)
        - [8.1 规则](#81-规则)
            - [8.1.1 内联函数(inline function)小于10行](#811-内联函数inline-function小于10行)
            - [8.1.2 使用内联函数代替函数宏](#812-使用内联函数代替函数宏)
        - [8.2 编码建议](#82-编码建议)
            - [8.2.1 内联函数应该放在头文件中声明，并在函数前添加inline关键字](#821-内联函数应该放在头文件中声明并在函数前添加inline关键字)
            - [8.2.2 入参尽量用const引用取代指针](#822-入参尽量用const引用取代指针)
            - [8.2.3 消除未使用函数参数](#823-消除未使用函数参数)
            - [8.2.4 尽量少用缺省参数](#824-尽量少用缺省参数)
            - [8.2.5 尽量少用函数指针](#825-尽量少用函数指针)
            - [8.2.6 编写简短的函数](#826-编写简短的函数)
    - [9 类](#9-类)
        - [9.1 原则](#91-原则)
            - [9.1.1 类设计：类职责单一](#911-类设计类职责单一)
            - [9.1.2 类设计：隐藏信息](#912-类设计隐藏信息)
            - [9.1.3 类设计：尽量使类的接口正交、少而完备](#913-类设计尽量使类的接口正交少而完备)
            - [9.1.4 类继承：用组合代替继承](#914-类继承用组合代替继承)
            - [9.1.5 类继承：避免使用多重继承](#915-类继承避免使用多重继承)
            - [9.1.6 重载：尽量不重载操作符，保持重载操作符的自然语义](#916-重载尽量不重载操作符保持重载操作符的自然语义)
        - [9.2 规则](#92-规则)
            - [9.2.1 模块间对外接口类不要暴露私有和保护成员](#921-模块间对外接口类不要暴露私有和保护成员)
            - [9.2.2 避免成员函数返回成员可写的引用或者指针](#922-避免成员函数返回成员可写的引用或者指针)
            - [9.2.3 禁止类之间循环依赖](#923-禁止类之间循环依赖)
            - [9.2.4 包含成员变量的类，须定义构造函数或者默认构造函数](#924-包含成员变量的类须定义构造函数或者默认构造函数)
            - [9.2.5 为避免隐式转换，将单参数构造函数声明为explicit](#925-为避免隐式转换将单参数构造函数声明为explicit)
            - [9.2.6 包含资源管理的类应自定义拷贝构造函数、赋值操作符和析构函数](#926-包含资源管理的类应自定义拷贝构造函数赋值操作符和析构函数)
            - [9.2.7 让operator=返回*this的引用](#927-让operator返回this的引用)
            - [9.2.8 在operator=中检查给自己赋值的情况](#928-在operator中检查给自己赋值的情况)
            - [9.2.9 在拷贝构造函数、赋值操作符中对所有数据成员赋值](#929-在拷贝构造函数赋值操作符中对所有数据成员赋值)
            - [9.2.10 通过基类指针来执行删除操作时，基类的析构函数设为公有且虚拟的](#9210-通过基类指针来执行删除操作时基类的析构函数设为公有且虚拟的)
            - [9.2.11 避免在构造函数和析构函数中调用虚函数](#9211-避免在构造函数和析构函数中调用虚函数)
            - [9.2.12 使用public继承而不是protected/private继承](#9212-使用public继承而不是protectedprivate继承)
            - [9.2.13 继承层次不超过4层](#9213-继承层次不超过4层)
            - [9.2.14 虚函数绝不使用缺省参数值](#9214-虚函数绝不使用缺省参数值)
            - [9.2.15 绝不重新定义继承而来的非虚函数](#9215-绝不重新定义继承而来的非虚函数)
            - [9.2.16 仅在输入参数类型不同、功能相同时重载函数](#9216-仅在输入参数类型不同功能相同时重载函数)
        - [9.3 编码建议](#93-编码建议)
            - [9.3.1 将数据成员设为私有的(struct除外)，并提供相关存取函数](#931-将数据成员设为私有的struct除外并提供相关存取函数)
            - [9.3.2 使用PIMPL模式，确保私有成员真正不可见](#932-使用pimpl模式确保私有成员真正不可见)
            - [9.3.3 拷贝构造函数和赋值操作符的参数定义成const引用类型](#933-拷贝构造函数和赋值操作符的参数定义成const引用类型)
            - [9.3.4 在析构函数中集中释放资源](#934-在析构函数中集中释放资源)
            - [9.3.5 避免派生类中定义与基类同名但参数类型不同的函数](#935-避免派生类中定义与基类同名但参数类型不同的函数)
            - [9.3.6 派生类重定义的虚函数也要声明virtual关键字](#936-派生类重定义的虚函数也要声明virtual关键字)
            - [9.3.7 使用重载以避免隐式类型转换](#937-使用重载以避免隐式类型转换)
            - [9.3.8 C/C++混用时，避免重载接口函数](#938-cc混用时避免重载接口函数)
    - [10 C++其他特性](#10-c其他特性)
        - [10.1 模板](#101-模板)
            - [10.1.1 谨慎使用模板，只使用模板的基础特性](#1011-谨慎使用模板只使用模板的基础特性)
            - [10.1.2 注意使用模板的代码膨胀](#1012-注意使用模板的代码膨胀)
            - [10.1.3 模板类型应该使用引用或指针](#1013-模板类型应该使用引用或指针)
            - [10.1.4 模板如果有约束条件，请在模板定义处显式说明](#1014-模板如果有约束条件请在模板定义处显式说明)
            - [10.1.5 两个模块之间接口中尽量不要暴露模板](#1015-两个模块之间接口中尽量不要暴露模板)
        - [10.2 其他](#102-其他)
            - [10.2.1 避免使用友元](#1021-避免使用友元)
            - [10.2.2 避免使用RTTI](#1022-避免使用rtti)
            - [10.2.3 使用sizeof(变量)而不是sizeof(类型)](#1023-使用sizeof变量而不是sizeof类型)
            - [10.2.4 只在定义移动构造函数与移动赋值操作时使用右值引用，不要使用 std::forward](#1024-只在定义移动构造函数与移动赋值操作时使用右值引用不要使用-stdforward)
            - [10.2.5 对于迭代器和其他模板对象使用前缀形式 (++i) 的自增,、自减运算符](#1025-对于迭代器和其他模板对象使用前缀形式-i-的自增自减运算符)
            - [10.2.6 用 constexpr 来定义真正的常量，或实现常量初始化](#1026-用-constexpr-来定义真正的常量或实现常量初始化)
            - [10.2.7 0, nullptr 和 NULL](#1027-0-nullptr-和-null)
            - [10.2.8 auto](#1028-auto)
            - [10.2.9 适当使用 lambda 表达式。别用默认 lambda 捕获，所有捕获都要显式写出来](#1029-适当使用-lambda-表达式别用默认-lambda-捕获所有捕获都要显式写出来)
    - [11 命名约定](#11-命名约定)
        - [11.1 通用命名规则](#111-通用命名规则)
            - [11.1.1 函数命名，变量命名，文件命名要有描述性；少用缩写](#1111-函数命名变量命名文件命名要有描述性少用缩写)
        - [11.2 文件命名](#112-文件命名)
        - [11.3 类型命名](#113-类型命名)
            - [11.3.1 类型名称的每个单词首字母均大写，不包含下划线：MyExcitingClass, MyExcitingEnum](#1131-类型名称的每个单词首字母均大写不包含下划线myexcitingclass-myexcitingenum)
        - [11.4 变量命名](#114-变量命名)
            - [11.4.1 变量 (包括函数参数) 和数据成员名小写，单词首字母可大写，类的成员变量以m_开头](#1141-变量-包括函数参数-和数据成员名小写单词首字母可大写类的成员变量以m_开头)
        - [11.5 常量命名](#115-常量命名)
            - [11.5.1 声明为constexpr或const的变量，或在程序运行期间其值始终保持不变的，命名时以“k”开头，大小写混合](#1151-声明为constexpr或const的变量或在程序运行期间其值始终保持不变的命名时以k开头大小写混合)
        - [11.6 函数命名](#116-函数命名)
            - [11.6.1 常规函数使用大小写混合，取值和设值函数则要求与变量名匹配](#1161-常规函数使用大小写混合取值和设值函数则要求与变量名匹配)
        - [11.7 命名空间命名](#117-命名空间命名)
        - [11.8 枚举命名](#118-枚举命名)
            - [11.8.1 枚举的命名应当和常量或宏一致：kEnumName 或是 ENUM_NAME](#1181-枚举的命名应当和常量或宏一致kenumname-或是-enum_name)
        - [11.9 宏命名](#119-宏命名)
    - [12 资源分配和释放](#12-资源分配和释放)
        - [12.1 原则](#121-原则)
            - [12.1.1 明确产品动态内存的申请与释放原则](#1211-明确产品动态内存的申请与释放原则)
        - [12.2 规则](#122-规则)
            - [12.2.1 明确operator new的行为和检查策略](#1221-明确operator-new的行为和检查策略)
            - [12.2.2 释放内存后，要立即将指针设置为NULL，防止产生野指针](#1222-释放内存后要立即将指针设置为null防止产生野指针)
            - [12.2.3 单个对象释放使用delete，数组对象释放使用delete []](#1223-单个对象释放使用delete数组对象释放使用delete-)
            - [12.2.4 释放结构(类)指针时，首先释放其成员指针的内存空间](#1224-释放结构类指针时首先释放其成员指针的内存空间)
            - [12.2.5 释放指针数组时，首先释放数组每个元素指针的内存](#1225-释放指针数组时首先释放数组每个元素指针的内存)
            - [12.2.6 不要返回局部对象指针](#1226-不要返回局部对象指针)
            - [12.2.7 不要强制关闭线程](#1227-不要强制关闭线程)
        - [12.3 编码建议](#123-编码建议)
            - [12.3.1 使用new, delete的封装方式来分配与释放内存](#1231-使用new-delete的封装方式来分配与释放内存)
            - [12.3.2 避免在不同的模块中分配和释放内存](#1232-避免在不同的模块中分配和释放内存)
            - [12.3.3 使用 RAII 特性来帮助追踪动态分配](#1233-使用-raii-特性来帮助追踪动态分配)
    - [13 异常和错误处理](#13-异常和错误处理)
        - [13.1 原则](#131-原则)
            - [13.1.1 减少不必要的异常](#1311-减少不必要的异常)
            - [13.1.2 建立合理的错误处理策略](#1312-建立合理的错误处理策略)
            - [13.1.3 离错误最近的地方处理错误或转换错误](#1313-离错误最近的地方处理错误或转换错误)
        - [13.2 规则](#132-规则)
            - [13.2.1 构造和析构函数不能抛出异常](#1321-构造和析构函数不能抛出异常)
            - [13.2.2 通过传值的方式抛出，通过引用的方式捕获](#1322-通过传值的方式抛出通过引用的方式捕获)
            - [13.2.3 确保抛出的异常一定能被捕捉到](#1323-确保抛出的异常一定能被捕捉到)
            - [13.2.4 确保异常发生后资源不泄漏](#1324-确保异常发生后资源不泄漏)
            - [13.2.5 独立编译模块或子系统的外部接口禁止抛异常](#1325-独立编译模块或子系统的外部接口禁止抛异常)
            - [13.2.6 错误发生时，至少确保符合基本保证；对于事务处理，至少符合强保证；对于原子操作，符合无错误保证](#1326-错误发生时至少确保符合基本保证对于事务处理至少符合强保证对于原子操作符合无错误保证)
    - [14 标准库](#14-标准库)
        - [14.1 规则](#141-规则)
            - [14.1.1 避免使用auto_ptr(C++11已废弃)](#1411-避免使用auto_ptrc11已废弃)
            - [14.1.2 仅将scoped_ptr、shared_ptr和unique_ptr用于管理单个对象](#1412-仅将scoped_ptrshared_ptr和unique_ptr用于管理单个对象)
            - [14.1.3 如果涉及循环引用，使用weak_ptr解开循环](#1413-如果涉及循环引用使用weak_ptr解开循环)
            - [14.1.4 使用make_shared代替new生成shared_ptr](#1414-使用make_shared代替new生成shared_ptr)
            - [14.1.5 对于同一个对象一旦使用shared_ptr，后续就要处处使用shared_ptr](#1415-对于同一个对象一旦使用shared_ptr后续就要处处使用shared_ptr)
            - [14.1.6 对于返回自身的shared_ptr指针的对象，要从enable_shared_from_this类派生](#1416-对于返回自身的shared_ptr指针的对象要从enable_shared_from_this类派生)
            - [14.1.7 不要将使用不同版本stl、boost等模板库编译的模块连接在一起](#1417-不要将使用不同版本stlboost等模板库编译的模块连接在一起)
            - [14.1.8 不要保存string::c_str()指针](#1418-不要保存stringc_str指针)
        - [14.2 编码建议](#142-编码建议)
            - [14.2.1 不要将stl、boost等模板库中的数据类型传递到动态链接库或者其它进程中](#1421-不要将stlboost等模板库中的数据类型传递到动态链接库或者其它进程中)
            - [14.2.2 使用容器时要评估大量插入删除是否会生成大量内存碎片](#1422-使用容器时要评估大量插入删除是否会生成大量内存碎片)
            - [14.2.3 使用string代替char*](#1423-使用string代替char)
            - [14.2.4 使用stl、boost等知名模板库提供的容器，而不要自己实现容器](#1424-使用stlboost等知名模板库提供的容器而不要自己实现容器)
            - [14.2.5 使用新的标准库头文件](#1425-使用新的标准库头文件)
    - [15 代码编译](#15-代码编译)
        - [15.1 规则](#151-规则)
            - [15.1.1 使用编译器的最高告警级别，理解所有的告警，通过修改代码而不是降低告警级别来消除所有告警](#1511-使用编译器的最高告警级别理解所有的告警通过修改代码而不是降低告警级别来消除所有告警)
            - [15.1.2 在产品软件（项目组）中，要统一编译开关、静态检查选项以及相应告警清除策略](#1512-在产品软件项目组中要统一编译开关静态检查选项以及相应告警清除策略)
            - [15.1.3 本地构建工具（如PC-Lint）的配置应该和持续集成的一致](#1513-本地构建工具如pc-lint的配置应该和持续集成的一致)
            - [15.1.4 使用版本控制（配置管理）系统，及时签入通过本地构建的代码，确保签入的代码不会影响构建成功](#1514-使用版本控制配置管理系统及时签入通过本地构建的代码确保签入的代码不会影响构建成功)
    - [16 程序效率](#16-程序效率)
        - [16.1 C++语言特性的性能分级](#161-c语言特性的性能分级)
        - [16.2 C++语言的性能优化指导](#162-c语言的性能优化指导)
            - [16.2.1 先测量再优化，避免不成熟的优化](#1621-先测量再优化避免不成熟的优化)
            - [16.2.2 选用合适的算法和数据结构](#1622-选用合适的算法和数据结构)
            - [16.2.3 在构造函数中用初始化代替赋值](#1623-在构造函数中用初始化代替赋值)
            - [16.2.4 当心空的构造函数或析构函数的开销](#1624-当心空的构造函数或析构函数的开销)
            - [16.2.5 对象参数尽量传递引用(优先)或指针而不是传值](#1625-对象参数尽量传递引用优先或指针而不是传值)
            - [16.2.6 尽量减少临时对象](#1626-尽量减少临时对象)
            - [16.2.7 优先采用前置自增/自减](#1627-优先采用前置自增自减)
            - [16.2.8 简单访问方法尽量采用内联函数](#1628-简单访问方法尽量采用内联函数)
            - [16.2.9 要审视标准库的性能规格](#1629-要审视标准库的性能规格)
            - [16.2.10 用对象池重载动态内存管理器](#16210-用对象池重载动态内存管理器)
            - [16.2.11 注意大尺寸数组的初始化效率](#16211-注意大尺寸数组的初始化效率)
            - [16.2.12 避免在函数内部的小块内存分配](#16212-避免在函数内部的小块内存分配)
    - [17 并发](#17-并发)
        - [17.1 规则](#171-规则)
            - [17.1.1 多线程、进程并行访问共享资源时，一定要加锁保护](#1711-多线程进程并行访问共享资源时一定要加锁保护)
            - [17.1.2 锁的职责单一](#1712-锁的职责单一)
            - [17.1.3 锁范围尽量小，只锁对应资源操作代码](#1713-锁范围尽量小只锁对应资源操作代码)
            - [17.1.4 避免嵌套加锁；如果必须加锁，务必保证不同地方的加锁顺序是一样的](#1714-避免嵌套加锁如果必须加锁务必保证不同地方的加锁顺序是一样的)
        - [17.2 编码建议](#172-编码建议)
            - [17.2.1 进程间通讯，使用自己保证互斥的数据库系统、共享内存，或socket消息机制；尽量避免使用文件等进程无法管理的资源](#1721-进程间通讯使用自己保证互斥的数据库系统共享内存或socket消息机制尽量避免使用文件等进程无法管理的资源)
            - [17.2.2 可重入函数尽量只使用局部变量和函数参数，少用全局变量、静态变量](#1722-可重入函数尽量只使用局部变量和函数参数少用全局变量静态变量)
            - [17.2.4 锁中避免使用跳转语句](#1724-锁中避免使用跳转语句)
    - [18 注释](#18-注释)
        - [18.1 注释风格](#181-注释风格)
            - [18.1.1 使用 // 或 /* */, 统一就好](#1811-使用--或---统一就好)
        - [18.2 文件注释](#182-文件注释)
            - [18.2.1 在每一个文件开头加入版权公告](#1821-在每一个文件开头加入版权公告)
        - [18.3 类注释](#183-类注释)
            - [18.3.1 每个类的定义都要附带一份注释, 描述类的功能和用法, 除非它的功能相当明显](#1831-每个类的定义都要附带一份注释-描述类的功能和用法-除非它的功能相当明显)
        - [18.4 函数注释](#184-函数注释)
            - [18.4.1 函数声明处的注释描述函数功能，定义处的注释描述函数实现](#1841-函数声明处的注释描述函数功能定义处的注释描述函数实现)
        - [18.5 变量注释](#185-变量注释)
            - [18.5.1 通常变量名本身足以很好说明变量用途，某些情况下，也需要额外的注释说明](#1851-通常变量名本身足以很好说明变量用途某些情况下也需要额外的注释说明)
        - [18.6 实现注释](#186-实现注释)
            - [18.6.1 对于代码中巧妙的，晦涩的，有趣的，重要的地方加以注释](#1861-对于代码中巧妙的晦涩的有趣的重要的地方加以注释)
        - [18.7 标点, 拼写和语法](#187-标点-拼写和语法)
            - [18.7.1 注意标点，拼写和语法；写的好的注释比差的要易读的多](#1871-注意标点拼写和语法写的好的注释比差的要易读的多)
        - [18.8 TODO 注释](#188-todo-注释)
            - [18.8.1 对那些临时的，短期的解决方案，或已经够好但仍不完美的代码使用TODO注释](#1881-对那些临时的短期的解决方案或已经够好但仍不完美的代码使用todo注释)
        - [18.9 弃用注释](#189-弃用注释)
            - [18.9.1 通过弃用注释（DEPRECATED comments）以标记某接口点已弃用](#1891-通过弃用注释deprecated-comments以标记某接口点已弃用)
    - [19 格式](#19-格式)
        - [19.1 行长度](#191-行长度)
            - [19.1.1 每一行代码字符数不超过80](#1911-每一行代码字符数不超过80)
        - [19.2 非ASCII字符](#192-非ascii字符)
            - [19.2.1 尽量不使用非ASCII字符，使用时必须使用UTF-8编码](#1921-尽量不使用非ascii字符使用时必须使用utf-8编码)
        - [19.3 空格还是制表位](#193-空格还是制表位)
            - [19.3.1 只使用空格, 每次缩进4个空格](#1931-只使用空格-每次缩进4个空格)
        - [19.4 函数声明与定义](#194-函数声明与定义)
            - [19.4.1 返回类型和函数名在同一行, 参数也尽量放在同一行, 如果放不下就对形参分行, 分行方式与函数调用一致](#1941-返回类型和函数名在同一行-参数也尽量放在同一行-如果放不下就对形参分行-分行方式与函数调用一致)
        - [19.5 Lambda表达式](#195-lambda表达式)
            - [19.5.1 Lambda表达式对形参和函数体的格式化和其他函数一致；捕获列表同理，表项用逗号隔开](#1951-lambda表达式对形参和函数体的格式化和其他函数一致捕获列表同理表项用逗号隔开)
        - [19.6 函数调用](#196-函数调用)
        - [19.7 条件语句](#197-条件语句)
            - [19.7.1 倾向于不在圆括号内使用空格，关键字if和else另起一行](#1971-倾向于不在圆括号内使用空格关键字if和else另起一行)
        - [19.8 循环和开关选择语句](#198-循环和开关选择语句)
            - [19.8.1 switch语句可以使用大括号分段，以表明cases之间不是连在一起的。在单语句循环里，括号可用可不用，空循环体应使用{} 或continue](#1981-switch语句可以使用大括号分段以表明cases之间不是连在一起的在单语句循环里括号可用可不用空循环体应使用-或continue)
        - [19.9 指针和引用表达式](#199-指针和引用表达式)
            - [19.9.1 句点或箭头前后不要有空格，指针/地址操作符(*, &)之后不能有空格](#1991-句点或箭头前后不要有空格指针地址操作符-之后不能有空格)
        - [19.10 布尔表达式](#1910-布尔表达式)
            - [19.10.1 如果一个布尔表达式超过标准行宽，断行方式要统一一下](#19101-如果一个布尔表达式超过标准行宽断行方式要统一一下)
        - [19.11 函数返回值](#1911-函数返回值)
            - [19.11.1 不要在return表达式里加上非必须的圆括号](#19111-不要在return表达式里加上非必须的圆括号)
        - [19.12 变量及数组初始化](#1912-变量及数组初始化)
            - [19.12.1 用 =, () 和 {} 均可](#19121-用---和--均可)
        - [19.13 预处理指令](#1913-预处理指令)
            - [19.13.1 预处理指令不要缩进，从行首开始](#19131-预处理指令不要缩进从行首开始)
        - [19.14 类格式](#1914-类格式)
            - [19.14.1 访问控制块的声明依次序是 public:，protected:，private:](#19141-访问控制块的声明依次序是-publicprotectedprivate)
        - [19.15 构造函数初始值列表](#1915-构造函数初始值列表)
            - [19.15.1 构造函数初始化列表放在同一行或按四格缩进并排多行](#19151-构造函数初始化列表放在同一行或按四格缩进并排多行)
        - [19.16 命名空间格式化](#1916-命名空间格式化)
            - [19.16.1 命名空间内容不缩进](#19161-命名空间内容不缩进)
        - [19.17 水平留白](#1917-水平留白)
        - [19.17.1 水平留白的使用根据在代码中的位置决定，永远不要在行尾添加没意义的留白](#19171-水平留白的使用根据在代码中的位置决定永远不要在行尾添加没意义的留白)
        - [19.18 垂直留白](#1918-垂直留白)
            - [19.18.1 垂直留白越少越好](#19181-垂直留白越少越好)
    - [20 可测性](#20-可测性)
        - [20.1 原则](#201-原则)
            - [20.1.1 模块划分清晰，接口明确，耦合性小，有明确输入和输出，否则单元测试实施困难](#2011-模块划分清晰接口明确耦合性小有明确输入和输出否则单元测试实施困难)
        - [20.2 规则](#202-规则)
            - [20.2.1 在同一项目组或产品组内，要有一套统一的为集成测试与系统联调准备的调测开关及相应打印函数，并且要有详细的说明](#2021-在同一项目组或产品组内要有一套统一的为集成测试与系统联调准备的调测开关及相应打印函数并且要有详细的说明)
            - [20.2.2 在同一项目组或产品组内，调测打印的日志要有统一的规定](#2022-在同一项目组或产品组内调测打印的日志要有统一的规定)
            - [20.2.3 使用断言记录内部假设](#2023-使用断言记录内部假设)
            - [20.2.4 不能用断言来检查运行时错误](#2024-不能用断言来检查运行时错误)
    - [21 安全性](#21-安全性)
        - [21.1 原则](#211-原则)
            - [21.1.1 对用户输入进行检查](#2111-对用户输入进行检查)
        - [21.2 规则](#212-规则)
            - [21.2.1 确保所有字符串是以NULL结束](#2121-确保所有字符串是以null结束)
            - [21.2.2 不要将边界不明确的字符串写到固定长度的数组中](#2122-不要将边界不明确的字符串写到固定长度的数组中)
            - [21.2.3 避免整数溢出](#2123-避免整数溢出)
            - [21.2.4 避免符号错误](#2124-避免符号错误)
            - [21.2.5 避免截断错误](#2125-避免截断错误)
            - [21.2.6 避免使用strlen()计算二进制数据的长度](#2126-避免使用strlen计算二进制数据的长度)
    - [22 可移植性](#22-可移植性)
        - [22.1 编码建议](#221-编码建议)
            - [22.1.1 不直接使用C++的基本数据类型，不要假定其存储尺寸长度](#2211-不直接使用c的基本数据类型不要假定其存储尺寸长度)
            - [22.1.2 避免指针截断](#2212-避免指针截断)
            - [22.1.3 注意数据类型对齐问题](#2213-注意数据类型对齐问题)
            - [22.1.4 在涉及网络字节序处理时，要注意进行网络字节序与本地字节序的转换](#2214-在涉及网络字节序处理时要注意进行网络字节序与本地字节序的转换)
            - [22.1.5 避免无符号数与有符号数的转换](#2215-避免无符号数与有符号数的转换)
            - [22.1.6 创建64 位常量时使用LL 或ULL 作为后缀](#2216-创建64-位常量时使用ll-或ull-作为后缀)
            - [22.1.7 区分sizeof(void *)和sizeof(int)](#2217-区分sizeofvoid-和sizeofint)
            - [22.1.8 编译器，操作系统相关的代码独立出来](#2218-编译器操作系统相关的代码独立出来)

<!-- /TOC -->
------------------------------------------------
## 1 规范制定说明  
### 1.1 前言  
为提高产品代码质量，指导广大软件开发人员编写出简洁、可维护、可靠、可测试、高效、可移植的代码，编程规范修订工作组分析、总结了各种典型编码问题，并参考了业界编程规范近年来的成果，编写了本规范。  
### 1.2 代码总体原则  
跟C语言编程一样，C++编程遵循通用原则： 
1、清晰。清晰性是易于维护、易于重构的程序必需具备的特征。 
2、简洁。简洁就是易于理解并易于实现。 
3、风格合适。在修改不同的代码时，应当与被修改代码保持相同的编程风格。 
除此之外，C++编程还应该注意以下方面： 
1、正确理解并使用C++ 
面向对象技术使得程序结构清晰、简单，提高了代码的重用性，但又隐藏了很多内部实现细节，内存模型复杂，不小心会误入陷阱。比如在函数重载时，由于不注重隐式转换导致的程序错误，在派生时，由于未正确定义析构函数导致的内存异常。
此外，为了简化代码，改善代码结构，提高编程效率，在引入新特性和第三方库，如：模板技术、STL时，由于缺乏足够的理解，使用中屡次发生问题，比如对迭代器(Iterator)使用不当导致功能失常，甚至程序崩溃。
所以，必须深入理解C++对象特性和内存管理等，了解编译器背后所做的处理，才能在编程中知道如何正确使用。 
2、安全高效 
跟其他流行的高级语言、脚本语言相比，C++运行速度快，具有直接操作硬件、访问内存的能力，提供了指针、地址运算等灵活特性，程序员可以任意发挥，增加了出错的几率。所以在追求速度与灵活性的同时，一定要注意保持程序的健壮性。在增强代码稳定性过程中，程序员通常采用if-else等防御式编程，使得代码非常臃肿，可适当采用RAII、智能指针等技术。  
### 1.3 规范实施解释  
本规范制定了编写C++语言程序的基本原则、规则和建议。
本规范适用于公司内使用C++语言编码的所有软件。本规范自发布之日起生效，对以后新编写的和修改的代码应遵守本规范。
本规范由软件研发一部发布和维护。在某些情况下需要违反本规范给出的规则时，相关团队必须通过一个正式的流程来评审、决策规则违反的部分，个体程序员不得违反本规范中的相关规则。  
### 1.4 术语  
原则：编程时必须坚持的指导思想。
规则：编程时强制必须遵守的约定。
建议：编程时必须加以考虑的约定。
说明：对此原则/规则/建议进行必要的解释。
示例：对此原则/规则/建议从好、不好两个方面给出例子。  
  
------------------------------------------------  
## 2 头文件  
通常来说，每一个.cpp文件对应一个.h文件，但也有一些例外，如单元测试代码和只包含main()函数的.cpp文件。
头文件的包含关系体现了部分的系统设计。不合理的头文件包含关系是编译时间过长的根本原因，同时不合理的头文件包含关系实际上也体现了系统设计上的不合理。
依赖：本章节特指编译依赖。若x.h包含了y.h，则称作x依赖y。依赖关系会进行传导，如x.h包含y.h， 而y.h又包含了z.h，则x通过y依赖了z。依赖将导致编译时间的上升。虽然依赖是不可避免的，也是必须的，但是不良的设计会导致整个系统的依赖关系无比复杂，使得任意一个文件的修改都要重新编译整个系统，导致编译时间巨幅上升。
大部分产品修改一处代码，都得需要编译整个工程，因此合理的划分头文件、以及头文件之间的包含关系，可以从根本上降低编译时间。
 若包含了头文件aa.h，则就引入了新的依赖：一旦aa.h被修改，任何直接和间接包含aa.h代码都会被重新编译。如果aa.h又包含了其他头文件如bb.h，那么bb.h的任何改变都将导致所有包含了aa.h的代码被重新编译，在敏捷开发方式下，代码会被频繁构建，漫长的编译时间将极大的阻碍频繁构建。因此，我们倾向于减少包含头文件，尤其是在头文件中包含头文件，以控制改动代码后的编译时间。
合理的头文件划分体现了系统设计的思想，但是从编程规范的角度看，仍然有一些通用的方法，用来合理规划头文件。本章节介绍的一些方法，对于合理规划头文件会有一定的助。 
### 2.1 原则  
#### 2.1.1 头文件中适合放置接口的声明，不适合放置实现  
说明：头文件是模块（Module）或单元（Unit）的对外接口。头文件中应放置对外部的声明，如对外提供的函数声明、宏定义、类型定义等。头文件中应当体现的是类的接口设计和架构设计，而将实现部分放置于.cpp文件中。
类的方法实现应当放置于.cpp文件中，并且为便于类方法实现而定义的内部使用的函数声明不应放在头文件中，类内部使用的宏、枚举、结构定义不应放入头文件中。类内的变量，避免直接暴露给外部，应当通过函数接口的方式提供给外部使用。  
#### 2.1.2 头文件应当职责单一  
说明：头文件过于复杂，依赖过于复杂是导致编译时间过长的主要原因。很多现有代码中头文件过大，职责过多，再加上循环依赖的问题，可能导致为了在.cpp中使用一个宏，而包含十几个头文件。  
#### 2.1.3 头文件应向稳定的方向包含  
说明：头文件的包含关系是一种依赖，一般来说，应当让不稳定的模块依赖稳定的模块，从而当不稳定的模块发生变化时，不会影响（编译）稳定的模块。
除了不稳定的模块依赖于稳定的模块外，更好的方式是两个模块共同依赖于接口，这样任何一个模块的内部实现更改都不需要重新编译另外一个模块。在这里，我们假设接口本身是最稳定的。
延伸阅读材料：推荐开发人员使用“依赖倒置”原则，即由使用者制定接口，服务提供者实现接口。  
### 2.2 规则  
#### 2.2.1 Self-contained 头文件
说明：头文件应该能够自给自足（self-contained,也就是可以作为第一个头文件被引入），以 .h结尾。不过有一个例外，即一个文件并不是self-contained的，而是作为文本插入到代码某处。
如果.h文件声明了一个模板或内联函数，同时也在该文件加以定义。凡是有用到这些的.cpp文件，就得统统包含该头文件，否则程序可能会在构建中链接失败。但也同样有个例外：如果某函数模板为所有相关模板参数显式实例化，或本身就是某类的一个私有成员，那么它就只能定义在实例化该模板的.cpp文件里。  
#### 2.2.2 #define 保护  
说明：在程序设计中，应该避免头文件的多次包含，但当无法避免时，应当
采取阻止头文件内容被包含多于一次的机制。通常时为头文件配置一个宏，当头文件第一次被包含时宏被定义，再次被包含时通过判断宏是否被定义来避免头文件的多次包含。
所有头文件都应当使用#define 防止头文件被多重包含，命名格式为：
FILENAME_H，
为了保证唯一性，更好的命名围为：
PROJECTNAME_PATH_FILENAME_H。
注：没有在宏最前面加上“_"，即使用FILENAME_H代替_FILENAME_H_，是因为一般以"_"和”__"开头的标识符为系统保留或者标准库使用，在有些静态检查工具中，若全局可见的标识符以"_"开头会给出告警。
定义包含保护符时，应该遵守如下规则：
1保护符使用唯一名称；
2不要在受保护部分的前后放置代码或者注释。
示例：假定VOS工程的timer模块的timer.h，其目录为VOS/include/timer/timer.h,应按如下方式保护： 
```
#ifndef VOS_INCLUDE_TIMER_TIMER_H 
#define VOS_INCLUDE_TIMER_TIMER_H 
... 
#endif
```
也可以使用如下简单方式保护:
```
#ifndef TIMER_H 
#define TIMER_H
.. 
#endif
```
例外情况：头文件的版权声明部分以及头文件的整体注释部分（如阐述此头文件的开发背景、使用注意事项等）可以放在保护符(#ifndef XX_H)前面。  
#### 2.2.3 前置声明  
说明：尽可能地避免使用前置声明。使用 #include 包含需要的头文件即可。
所谓前置声明，即对类、函数和模板的纯粹声明，不包含其定义。
多余的 #include 会迫使编译器展开更多的文件，处理更多的输入，同时#include 使代码因为头文件中无关的改动而被重新编译多次。而前置声明却可以减少大量的编译时间，但前置声明的缺点也十分明显。
1前置声明隐藏了依赖关系，头文件改动时，用户的代码会跳过必要的重新编译过程。
2前置声明可能会被库的后续更改所破坏。前置声明函数或模板有时会妨碍头文件开发者变动其 API. 例如扩大形参类型，加个自带默认参数的模板形参等等。
3前置声明来自命名空间 std:: 的 symbol 时，其行为未定义。
4很难判断什么时候该用前置声明，什么时候该用 #include 。极端情况下，用前置声明代替 includes 甚至都会暗暗地改变代码的含义：  
```  
// b.h;
struct B {};
struct D : B {}  
  
// good_user.cpp:
#include "b.h"  
void f(B*);
void f(void*);
void test(D* x) { f(x); } // calls f(B*)  
```  
如果 #include 被 B 和 D 的前置声明替代， test() 就会调用 f(void*) 。
5仅仅为了能前置声明而重构代码（比如用指针成员代替对象成员）会使代码变得更慢更复杂。
因此应尽量避免前置声明那些定义在其他项目中的实体。同时包含函数时总是使用 #include，而包含类模板时优先使用 #include 。  
#### 2.2.4 #include 的路径及顺序  
说明：使用标准的头文件包含顺序可增强可读性，避免隐藏依赖：相关头文件， C 库，C++ 库，其他库的 .h，本项目内的 .h。
项目内头文件应按照项目源代码目录树结构排列，避免使用 UNIX 特殊的快捷目录 . (当前目录) 或 .. (上级目录)。  
#### 2.2.5 禁止包含用不到的头文件  
说明：很多系统中头文件包含关系复杂，开发人员为了省事起见，可能不会去一一钻研，直接包含一切想到的头文件，甚至有些项目干脆发布了一个god.h，其中包含了所有头文件，然后发布给各个平台上的软件使用，这种只图一时省事的做法，导致整个系统的编译时间进一步恶化，并对后来人的维护造成了巨大的麻烦。  
#### 2.2.6 禁止在.cpp文件中通过extern的方式使用外部函数接口、变量  
说明：若a.cpp使用了b.cpp定义的foo()函数，则应当在b.h中声明int foo(int input)；并在a.cpp中通过#include <b.h>来使用foo。禁止通过在a.cpp中直接写extern int foo(int input);来使用foo，后面这种写法容易在foo改变时可能导致声明和定义不一致。  
#### 2.2.7 禁止在extern "C"中包含头文件  
说明：在extern "C"中包含头文件，会导致extern "C"嵌套，Visual Studio对extern "C"嵌套层次有限制，嵌套层次太多会编译错误。 在extern "C"中包含头文件，可能会导致被包含头文件的原有意图遭到破坏。例如，存在a.h和b.h两
个头文件： 
```  
#ifndef A_H__
#define A_H__

#ifdef __cplusplus
void foo(int);
#define a(value) foo(value)
#else
void a(int)
#endif

#endif /* A_H__ */
```  
```  
#ifndef B_H__
#define B_H__

#ifdef __cplusplus
extern "C" {
#endif

#include "a.h"
    void b();

#ifdef __cplusplus
}
#endif

#endif /* B_H__ */
```  
使用C++预处理器展开b.h，将会得到
``` 
extern "C" { 
    void foo(int); 
    void b();
}
``` 
按照a.h作者的本意，函数foo是一个C++自由函数，其链接规范为"C++"。但在b.h中，由于#include "a.h"被放到了extern "C" { }的内部，函数foo的链接规范被不正确地更改了。  
### 2.3 编码建议
#### 2.3.1 一个模块通常包含多个.cpp文件，建议放在同一个目录下，目录名即为模块名。为方便外部使用者，建议每一个模块提供一个.h，文件名为目录名  
说明：需要注意的是，这个.h并不是简单的包含所有内部的.h，它是为了模块使用者的方便，对外整体提供的模块接口。  
#### 2.3.2 如果一个模块包含多个子模块，则建议每一个子模块提供一个对外的.h，文件名为子模块名  
#### 2.3.3 头文件不要使用非习惯用法的扩展名，如.inc   

------------------------------------------------  
## 3 常量  
不变的值更易于理解、跟踪和分析，所以应该尽可能地使用常量代替变量，定义值的时候，应该把const作为默认的选项。  
### 3.1 规则  
#### 3.1.1 使用const常量取代宏  
说明：相比于常量，宏的缺点显而易见。
1宏是简单的文本替换，在预处理阶段时完成，运行报错时直接报相应的值；2跟踪调试时也是显示值，而不是宏名；
3宏没有类型检查，不安全；
4宏没有作用域。
示例：
``` 
#define MAX_MSISDN_LEN (20) //不好的例子
const int MAX_MSISDN_LEN = 20; //好的例子
``` 
### 3.1.2 一组相关的整型常量应定义为枚举  
说明：之所以使用枚举，基于：枚举比#define或const int更安全，因为编译器会检查参数值是否是否位于枚举取值范围内，从而避免错误发生。
示例：
``` 
//好的例子：
enum DayOfWeek{sunday, monday, tuesday, wednesday, thursday, friday, saturday};
enum Color{black, blue, white, red, purple};
BOOL ColorizeCalendar(DayOfWeek today, Color todaysColor);
ColorizeCalendar(blue, sunday); //编译报错，Blue和Sunday位置错误
``` 
``` 
//不好的例子: 
const int sunday = 0;
const int monday = 1;
const int black = 0;
const int blue = 1;
BOOL ColorizeCalendar(int today, int todaysColor);
ColorizeCalendar(blue, sunday); //不会报错
``` 
当枚举值需要对应到具体数值时，须在声明时显示赋值。否则不需要显式赋值，以避免重复赋值，降低维护(增加、删除成员)工作量。
应当尽量避免枚举值重复，如必须重复也要用已定义的枚举来修饰，例如：
``` 
typedef enum
{
    RTCP_SR = 200,
    RTCP_MIN_TYPE = RTCP_SR, //must be lowest known type
    RTCP_RR = 201,
    RTCP_SDES = 202,
    RTCP_BYE = 203,
    RTCP_APP = 204,
    RTCP_RTPFB = 205,
    RTCP_PSFB = 206,
    RTCP_XR = 207,
    RTCP_RSI = 208,
    RTCP_PUBPORTS = 209,
    RTCP_MAX_TYPE = RTCP_PUBPORTS //must be highest known type
} rtcp_type_t;
``` 
#### 3.1.3 不相关的常量，即使取值一样，也必须分别定义
说明：一个常量只用来表示一个特定功能，即一个常量不能有多种用途。  
#### 3.1.4 尽可能使用const  
说明：在声明的变量或参数前加上关键字const用于指明变量值不可被篡改 。类成员函数加上const限定符表明该函数不会修改类成员变量的状态。
使用const常见的场景：
1函数参数：传递引用时，如果函数不会修改传入参数, 该形参应声明为const。 
2成员函数：访问函数(如get函数)；不修改任何数据成员的函数；未调用非const函数、未返回数据成员的非const指针或引用的函数。 
3数据成员：如果数据成员在对象构造之后不再发生变化, 可将其定义为const。  

------------------------------------------------
## 4 变量
### 4.1 原则  
#### 4.1.1 一个变量只有一个功能，不能把一个变量用作多种用途  
说明：一个变量只用来表示一个特定功能，不能把一个变量作多种用途，即同一变量取值不同时，其代表的意义也不同。  
#### 4.1.2 结构功能单一；不要设计面面俱到的数据结构  
说明：相关的一组信息才是构成一个结构体的基础，结构的定义应该可以明确的描述一个对象，而不是一组相关性不强的数据的集合。设计结构时应力争使结构代表一种现实事务的抽象，而不是同时代表多种。结构中的各元素应代表同一事务的不同侧面，而不应把描述没有关系或关系很弱的不同事务的元素放到同一结构中。
示例：如下结构不太清晰、合理。
```
typedef struct STUDENT_STRU
{
    unsigned char name[32]; /* student's name */
    unsigned char age; /* student's age */
    unsigned char sex; /* student's sex, as follows */
    /* 0 - FEMALE; 1 - MALE */
    unsigned char teacher_name[32]; /* the student teacher's name */
    unsigned char teacher_sex; /* his teacher sex */
} STUDENT;
```
若改为如下，会更合理些。
```
typedef struct TEACHER_STRU
{ 
    unsigned char name[32]; /* teacher name */
    unsigned char sex; /* teacher sex, as follows */
    /* 0 - FEMALE; 1 - MALE */
    unsigned int teacher_ind; /* teacher index */
} TEACHER;

typedef struct STUDENT_STRU
{
    unsigned char name[32]; /* student's name */
    unsigned char age; /* student's age */
    unsigned char sex; /* student's sex, as follows */
    /* 0 - FEMALE; 1 - MALE */
    unsigned int teacher_ind; /* his teacher index */
} STUDENT;
```  
#### 4.1.3 不用或者少用全局变量  
说明：单个文件内部可以使用static的全局变量，可以将其理解为类的私有成员变量。全局变量应该是模块的私有数据，不能作用对外的接口使用，使用static类型定义，可以有效防止外部文件的非正常访问，建议定义一个STATIC宏，在调试阶段，将STATIC定义为static，版本发布时，改为空，以便于后续的打补丁等操作。
```  
#ifdef _DEBUG
#define STATIC static
#else
#define STATIC
#endif
``` 
直接使用其他模块的私有数据，将使模块间的关系逐渐走向“剪不断理还乱”的耦合状态，这种情形是不允许的。  
### 4.2 原则  
#### 4.2.1 防止局部变量与全局变量同名  
说明：尽管局部变量和全局变量的作用域不同而不会发生语法错误，但容易使人误解。  
#### 4.2.2 通讯过程中使用的结构，必须注意字节序  
说明：通讯报文中，字节序是一个重要的问题，我司设备使用的cpu类型复杂多样，大小端、32位/64位的处理器也都有，如果结构会在报文交互过程中使用，必须考虑字节序问题。  
由于位域在不同字节序下，表现看起来差别更大，所以更需要注意。
对于这种跨平台的交互，数据成员发送前，都应该进行主机序到网络序的转换；接收时，也必须进行网络序到主机序的转换。  
#### 4.2.3 严禁使用未经初始化的变量作为右值  
说明：坚持建议4.3.3（在首次使用前初始化变量，初始化的地方离使用的地方越近越好。）可以有效避免未初始化错误。  
#### 4.2.4 禁止定义静态储存周期非POD变量，禁止使用含有副作用的函数初始化POD全局变量  
说明：禁止使用类的静态储存周期变量：由于构造和析构函数调用顺序的不确定性，它们会导致难以发现的 bug 。不过 constexpr 变量除外，毕竟它们又不涉及动态初始化或析构。
静态生存周期的对象，即包括了全局变量，静态变量，静态类成员变量和函数静态变量，都必须是原生数据类型 (POD : Plain Old Data): 即 int, char 和 float, 以及 POD 类型的指针、数组和结构体。
静态变量的构造函数、析构函数和初始化的顺序在 C++ 中是只有部分明确的，甚至随着构建变化而变化，导致难以发现的 bug.。所以除了禁用类类型的全局变量，我们也不允许用函数返回值来初始化 POD 变量，除非该函数（比如 getenv() 或 getpid() ）不涉及任何全局变量。函数作用域里的静态变量除外，毕竟它的初始化顺序是有明确定义的，而且只会在指令执行到它的声明那里才会发生。
同理，全局和静态变量在程序中断时会被析构，无论所谓中断是从 main() 返回还是对 exit() 的调用。析构顺序正好与构造函数调用的顺序相反。但既然构造顺序未定义，那么析构顺序当然也就不定了。比如，在程序结束时某静态变量已经被析构了，但代码还在跑——比如其它线程——并试图访问它且失败；再比如，一个静态 string 变量也许会在一个引用了前者的其它变量析构之前被析构掉。
综上所述，我们只允许 POD 类型的静态变量，即完全禁用 vector (使用 C 数组替代) 和 string (使用 const char [])。
如果您确实需要一个 class 类型的静态或全局变量，可以考虑在 main() 函数或 pthread_once() 内初始化一个指针且永不回收。注意只能用 raw 指针，别用智能指针，毕竟后者的析构函数涉及到上文指出的不定顺序问题。  
### 4.3 编码建议  
#### 4.3.1 构造仅有一个模块或函数可以修改、创建，而其余有关模块或函数只访问的全局变量，防止多个不同模块或函数都可以修改、创建同一全局变量的现象   
说明：降低全局变量耦合度。
#### 4.3.2 使用面向接口编程思想，通过API访问数据：如果本模块的数据需要对外部模块开放，应提供接口函数来设置、获取，同时注意全局数据的访问互斥  
说明：避免直接暴露内部数据给外部模型使用，是防止模块间耦合最简单有效的方法。
定义的接口应该有比较明确的意义，比如一个风扇管理功能模块，有自动和手动工作模式，那么设置、查询工作模块就可以定义接口为SetFanWorkMode，GetFanWorkMode；查询转速就可以定义为GetFanSpeed；风扇支持节能功能开关，可以定义EnabletFanSavePower等等。  
#### 4.3.3 在首次使用前初始化变量，初始化的地方离使用的地方越近越好，作用域越小越好  
说明：未初始化变量是C和C++程序中错误的常见来源。在变量首次使用前确保正确初始化。
在较好的方案中，变量的定义和初始化要做到亲密无间。
示例：
```
//不可取的初始化：无意义的初始化
int speedup_factor ＝ 0;
if (condition)
{
    speedup_factor = 2;
}
else
{
    speedup_factor = -1;
}
//不可取的初始化：初始化和声明分离
int speedup_factor;
if (condition)
{
    speedup_factor = 2;
}
else
{
    speedup_factor = -1;
}
//较好的初始化：使用默认有意义的初始化
int speedup_factor = -1;
if (condition)
{
    speedup_factor = 2;
}
//较好的初始化使用?:减少数据流和控制流的混合
int speedup_factor = condition?2:-1;
//较好的初始化：使用函数代替复杂的计算流
int speedup_factor = ComputeSpeedupFactor()；
```  
#### 4.3.4 尽量减少没有必要的数据类型默认转换与强制转换  
说明：当进行数据类型强制转换时，其数据的意义、转换后的取值等都有可能发生变化，而这些细节若考虑不周，就很有可能留下隐患。
示例：如下赋值，多数编译器不产生告警，但值的含义还是稍有变化。
```
char ch;
unsigned short int exam;
ch = -1;
exam = ch; // 编译器不产生告警，此时exam为0xFFFF。
``` 

------------------------------------------------
## 5 表达式  
### 5.1 规则  
#### 5.1.1 表达式的值在标准所允许的任何运算次序下都应该是相同的  
说明：除了少数操作符（函数调用操作符 ( )、&&、| |、? : 和 , （逗号）） 之外，子表达式所依据的运算次序是未指定的并会随时更改。注意，运算次序的问题不能使用括号来解决，因为这不是优先级的问题。
将复合表达式分开写成若干个简单表达式，明确表达式的运算次序，就可以有效消除非预期副作用。
1、自增或自减操作符
示例：
```
x = b[i] + i++;
```
b[i] 的运算是先于还是后于 i ++ 的运算，表达式会产生不同的结果，把自增运算做为单独的语句，可以避免这个问题。
```
x = b[i] + i;
i ++;
```
2﹑函数参数
说明：函数参数通常从右到左压栈，但函数参数的计算次序不一定与压栈次序相同。
示例：
```
x = func( i++, i);
```
应该修改代码明确先计算第一个参数：
```
i++;
x = func(i, i);
```
3、函数指针
说明：函数参数和函数自身地址的计算次序未定义。
示例：
```
p->task_start_fn(p++);
```
求函数地址p与计算p++无关，结果是任意值。必须单独计算p++：
``` 
p->task_start_fn(p);
p++;
```
4﹑函数调用
示例：
```
int g_var = 0;
int fun1() 
{ 
    g_var += 10; 
    return g_var; 
} 
int fun2() 
{ 
    g_var += 100; 
    return g_var; 
} 
int x = fun1() + fun2();  
```
编译器可能先计算fun1()，也可能先计算fun2()，由于x的结果依赖于函数fun1()/fun2()的计算次序（fun1()/fun2()被调用时修改和使用了同一个全局变量），则上面的代码存在问题。
应该修改代码明确fun1/ fun2的计算次序：
```  
int x = fun1(); 
x = x + fun2();
```  
5、嵌套赋值语句
说明：表达式中嵌套的赋值可以产生附加的副作用。不给这种能导致对运算次序的依赖提供任何机会的最好做法是，不要在表达式中嵌套赋值语句。
示例：
```  
x = y = y = z / 3; 
x = y = y++;
```  
6、volatile访问
说明：限定符volatile表示可能被其它途径更改的变量，例如硬件自动更新的寄存器。编译器不会优化对volatile变量的读取。
示例：下面的写法可能无法实现作者预期的功能：
```
/* volume变量被定义为volatile类型*/
UINT16 x = ( volume << 3 ) | volume; /* 在计算了其中一个子表达式的时候，volume的值可能已经被其它程序或硬件改变，导致另外一个子表达式的计算结果非预期，可能无法实现作者预期的功能*/
``` 
### 5.2 编码建议  
#### 5.2.1 函数调用不要作为另一个函数的参数使用，否则对于代码的调试、阅读都不利  
说明：如下代码不合理，仅用于说明当函数作为参数时，由于参数压栈次数不是代码可以控制的，可能造成未知的输出：
```
int g_var; 
int fun1() 
{ 
    g_var += 10;
    return g_var; 
} 
int fun2() 
{
    g_var += 100; 
    return g_var; 
} 
int main(int argc, char *argv[], char *envp[]) 
{ 
    g_var = 1; 
    printf("func1: %d, func2: %d\n", fun1(), fun2()); 
    g_var = 1; 
    printf("func2: %d, func1: %d\n", fun2(), fun1()); 
}
```
上面的代码，使用断点调试起来也比较麻烦，阅读起来也不舒服，所以不要为了节约代码行，而写这种代码。
#### 5.2.2 赋值语句不要写在if等语句中，或者作为函数的参数使用  
说明：因为if语句中，会根据条件依次判断，如果前一个条件已经可以判定整个条件，则后续条件语句不会再运行，所以可能导致期望的部分赋值没有得到运行。
示例：
```
int main(int argc, char *argv[], char *envp[])
{
    int a = 0;
    int b;
    if ((a == 0) || ((b = fun1()) > 10))
    {
        printf("a: %d\n", a);
    }
    printf("b: %d\n", b);
}
```
作用函数参数来使用，参数的压栈顺序不同可能导致结果未知。
看如下代码，能否一眼看出输出结果会是什么吗？好理解吗？
```
int g_var;
int main(int argc, char *argv[], char *envp[])
{
    g_var = 1;
    printf("set 1st: %d, add 2nd: %d\n", g_var = 10, g_var++);
    g_var = 1;
    printf("add 1st: %d, set 2nd: %d\n", g_var++, g_var = 10);
} 
```  
#### 5.2.3 用括号明确表达式的操作顺序，避免过分依赖默认优先级  
说明：使用括号强调所使用的操作符，防止因默认的优先级与设计思想不符而导致程序出错；同时使得代码更为清晰可读，然而过多的括号会分散代码使其降低了可读性。下面是如何使用括号的建议。
1. 一元操作符，不需要使用括号
```
x = ~a; /* 一元操作符，不需要括号*/
x = -a; /* 一元操作符，不需要括号*/
```
2. 二元以上操作符，如果涉及多种操作符，则应该使用括号
```
x = a + b + c; /* 操作符相同，不需要括号*/
x = f ( a + b, c ) /* 操作符相同，不需要括号*/
if (a && b && c) /* 操作符相同，不需要括号*/
x = (a * 3) + c + d; /* 操作符不同，需要括号*/
x = ( a == b ) ? a : ( a –b ); /* 操作符不同，需要括号*/
```
3 .即使所有操作符都是相同的，如果涉及类型转换或者量级提升，也应该使用括号控制计算的次序
以下代码将3个浮点数相加：
```
/* 除了逗号(,)，逻辑与(&&)，逻辑或(||)之外，C标准没有规定同级操作符是从左还是从右开始计算，以上表达式存在种计算次序：f4 = (f1 + f2) + f3 或f4 = f1 + (f2 + f3)，浮点数计算过程中可能四舍五入，量级提升，计算次序的不同会导致f4的结果不同，以上表达式在不同编译器上的计算结果可能不一样，建议增加括号明确计算顺序*/
f4 = f1 + f2 + f3; 
```
#### 5.2.4 赋值操作符不能使用在产生布尔值的表达式上  
说明：如果布尔值表达式需要赋值操作，那么赋值操作必须在操作数之外分别进行。这可以帮助避免= 和= =的混淆，帮助我们静态地检查错误。
示例：
```
x = y; 
if (x != 0) 
{ 
    foo (); 
} 
```
不能写成：
```
if (( x = y ) != 0) 
{ 
    foo (); 
} 
```
或者更坏的
```
if (x = y)
{
    foo (); 
}
```

------------------------------------------------
## 6 作用域
### 6.1 原则  
#### 6.1.1 使用命名空间归类  
说明：名字空间主要解决符号冲突问题。
示例：两个不同项目的全局作用域都有一个类 Foo, 这样在编译或运行时造成冲突。如果每个项目将代码置于不同名字空间中
```
namespace project1
{
    class Foo;
    //…
}
namespace project2
{
    class Foo;
    //…
}
```
作为不同符号自然不会冲突：project1::Foo 和 project2::Foo。
建议名字空间的名称采用全小写，为避免冲突，可采用项目(产品部件)或目录结构。
用名字空间把整个源文件封装起来, 以区别于其它名字空间，但是这些内容除外：文件包含(include), 全局标识的声明/定义以及类的前置声明。
### 6.2 规则  
#### 6.2.1 不要在头文件中或者#include之前使用using指示符  
说明：使用using会影响后续代码，易造成符号冲突，所以不要在头文件以及源文件中的#include之前使用using。
示例：
```
//头文件a.h
namespace A {
    int f(int);
}
//头文件b.h
namespace B {
    int f(int);
}
using namespace B;
void g()
{
    f(1); 
}
//源代码a.cpp
#include “a.h”
using namespace A; 
#include “b.h”
void main()
{
    g();//using namespace A在#include “b.h”之前，引发歧意：A::f，B::f调用不明确
}
```
### 6.3 编码建议
#### 6.3.1 尽量少使用嵌套类   
说明：一个类在另一个类中定义，这样的类被称为嵌套类。嵌套类是其外围类的成员，嵌套类也被称为成员类。
```
class Foo
{
private:
//Bar是嵌套在Foo中的成员类
  class Bar
  {
      //…
  };
};
```
跟其它类一样，嵌套类可以声明为public、private和protected属性，因此，从外部访问嵌套类，遵循类成员的访问规则。
一般来说，应该尽量少用嵌套类。嵌套类最适合用来对它们的外层类实现细节建模(如：方便实现链表、容器等算法)，且在这个类需要访问外围类所有成员(包括私有成员)时才使用嵌套类。 不要通过嵌套类来进行命名分组，应该使用名字空间。
#### 6.3.2 尽可能不使用局部类  
说明：定义在函数体内的类称为局部类。局部类只在定义它的局部域内可见。
局部类的成员函数必须被定义在类定义中，且不能超过15行代码。否则，代码将变得很难理解。  
#### 6.3.3 使用静态成员函数或名字空间内的非成员函数，避免使用全局函数   
说明：非成员函数放在名字空间内可避免污染全局作用域。
如果你必须定义非成员函数, 又只是在 .cpp 文件中使用它, 也可使用static关键字 (如 static int Foo() {...}) 限定其作用域。
函数和变量可以经由声明为 static 拥有内部链接性，这意味着你在这个文件中声明的这些标识符都不能在另一个文件中被访问。即使两个文件声明了完全一样名字的标识符，它们所指向的实体实际上是完全不同的。  

------------------------------------------------
## 7 函数
### 7.1 规则  
#### 7.1.1 禁止用memcpy、memset初始化非POD对象
说明：POD 全称是“Plain Old Data”，POD类型主要包括int, char, float，double，enum，void，指针等原始类型及其集合类型，不能使用封装和面对对象特性（如用户定义的构造/赋值/析构函数、基类、虚函数等）。
由于非POD类型比如非集合类型的class对象，可能存在虚函数，内存布局不确定等问题，这些和编译器有关，滥用内存拷贝可能会导致严重的问题。
并且对集合类型的class，使用直接的内存拷贝和比较，破坏了类信息隐蔽和数据保护的作用。因此，不提倡memcpy、memset操作。
示例：×××产品程序异常退出(core dump)。
经过现场环境的模似，程序产生COREDUMP，其原因是：在定义类的对象后，使用memset(this, 0, sizeof(*this))进行了类对象的初始化，将类的虚函数表指针被清空，从而导致使用空指针。
解决方案：使用C++构造函数初始化，不要使用memset函数初始化类对象。
#### 7.1.2 使用C++风格的类型转换，不要使用C风格的类型转换  
说明：C++的类型转换由于采用关键字，更醒目，更容易查找，编程中强迫程序员多停留思考片刻，谨慎使用强制转换。
C++使用const_cast, dynamic_cast, static_cast, reinterpret_cast等新的类型转换，它们允许用户选择适当级别的转换符，而不是像C那样全用一个转换符。
dynamic_cast：主要用于下行转换，dynamic_cast具有类型检查的功能。dynamic_cast有一定的开销，建议在调测代码中使用。
static_cast：和C风格转换相似可做值的强制转换，或上行转换(把派生类的指针或引用转换成基类的指针或引用)。该转换经常用于消除多重继承带来的类型歧义，是相对安全的。下行转换(把基类的指针或引用转换成派生类的指针或引用)时，由于没有动态类型检查，所以不安全的，不提倡下行转换。
reinterpret_cast：用于转换不相关的类型。reinterpret_cast强制编译器将某个类型对象的内存重新解释成另一种类型，相关代码可移植不好。建议对reinterpret_cast<> 的用法进行注释，有助于减少维护者在看到这种转换时的顾虑。
const_cast：用于移除对象的 const属性，使对象变得可修改。
示例：
```
extern void Fun(DerivedClass* pd);
void Gun(BaseClass* pb)
{
    //不好的例子: C风格强制转换，转换会导致对象布局不一致，编译不报错，运行时可能会崩溃
    DerivedClass* pd = (DerivedClass *)pb; 
    //好的例子: C++风格强制转换，明确知道pb实际指向DerivedClass
    DerivedClass* pd = dynamic_cast< DerivedClass *>(pb); 
    if(pd)
    Fun(pd);
}
```
### 7.2 编码建议  
#### 7.2.1 变量使用时才声明并初始化   
说明：变量在使用前未赋初值，是常见的低级编程错误。使用前才声明变量并同时初始化，非常方便地避免了此类低级错误。
在函数开始位置声明所有变量，后面才使用变量，作用域覆盖整个函数实现，容易导致如下问题：
1程序难以理解和维护：变量的定义与使用分离。
2变量难以合理初始化：在函数开始时，经常没有足够的信息进行变量初始化，往往用某个默认的空值(比如零)来初始化，这通常是一种浪费，如果变量在被赋于有效值以前使用，还会导致错误。
遵循变量作用域最小化原则与就近声明原则， 使得代码更容易阅读,方便了解变量的类型和初始值。特别是，应使用初始化的方式替代声明再赋值。
示例：
```
//不好的例子：声明与初始化分离
string name; //声明时未初始化：调用缺省构造函数
//…….
name=”zhangsan”; //再次调用赋值操作符函数；声明与定义在不同的地方，理解相对困难
//好的例子：声明与初始化一体，理解相对容易
string name(”zhangsan”); //调用一次构造函数
```
#### 7.2.2 避免构造函数做复杂的初始化，可以使用“init”函数 
说明：正如函数的变量都在函数内部初始化一样，类数据成员最好的初始化场所就是构造函数，数据成员都应该尽量在构造函数中初始化。
以下情况可以使用init()函数来初始化：  
1需要提供初始化返回信息。
2数据成员初始化可能抛异常。
3数据成员初始化失败会造成该类对象初始化失败，引起不确定状态。
4数据成员初始化依赖this指针：构造函数没结束，对象就没有构造出来，构造函数内不能使用this成员；
5数据成员初始化需要调用虚函数。在构造函数和析构函数中调用虚函数，会导致未定义的行为。
示例：数据成员初始化可能抛异常：
```
class CPPRule
{
public:
    CPPRule():size_(0), res (null) {}; //仅进行值初始化
    long init(int size) 
    {
        //根据传入的参数初始化size_, 分配资源res
    }
private:
    int size_;
    ResourcePtr* res;
};
```
```
//使用方法：
CPPRule a;
a.init(100);
```  
#### 7.2.3 初始化列表要严格按照成员声明顺序来初始化它们  
说明：编译器会按照数据成员在类定义中声明的顺序进行初始化，而不是按照初始化列表中的顺序，如果打乱初始化列表的顺序实际上不起作用，但会造成阅读和理解上的混淆；特别是成员变量之间存在依赖关系时可能导致BUG。
示例：
```
//不好的例子：初始化顺序与声明顺序不一致
class Employee 
{
public:
    Employee(const char* firstName, const char* lastName)
        : firstName_(firstName)
        , lastName_(lastName)
        , email_(firstName_ + "." + lastName_ + "@huawei.com") 
    {};
private:
    string email_, firstName_, lastName_;
};
```
类定义email_是在firstName_, lastName_之前声明，它将首先初始化，但使用了未初始化的firstName_和lastName_，导致错误。
在成员声明时，应按照成员相互依赖关系按顺序声明。  
#### 7.2.4 明确有外部依赖关系的全局与静态对象的初始化顺序  
说明：如果全局对象A的成员变量有外部依赖，比如依赖另外一个全局变量B，在A的构造函数中访问B，隐含的规则就是B先于A初始化，然而全局与静态对象的初始化与析构顺序未有严格定义，无法确保B已经完成初始化，而每次生成可执行程序都可能发生变化，这类BUG难以定位。
通常采用单例(Singleton)模式或者把有依赖关系的全局对象放在一个文件中定义来明确初始化顺序。
同一个文件中，若全局对象a在全局对象b之前定义，则a一定会在b之前初始化；但是不同文件中的全局对象就没有固定的初始化顺序。可以在main()或 pthread_once() 内初始化一个运行期间不回收的指针。  
#### 7.2.5 避免使用reinterpret_cast 
说明：reinterpret_cast用于转换不相关类型。尝试用reinterpret_cast将一种类型强制转换另一种类型，这破坏了类型的安全性与可靠性，是一种不安全的转换。不同类型之间尽量避免转换。  
#### 7.2.6 避免使用const_cast   
说明：const_cast用于移除对象的 const性质。
const属性提供一种安全感，让程序员知道这个定义是固定不变的，从而不需要担心后面的变化。如果const属性在程序员不知道的地方被消除，会带来很多严重的后果。
示例：不好的例子
```
unsigned const int arraySize = 1024;
int &newArraySize = const_cast<int&>(arraySize);
newArraySize = 2048;
```
这里如果不通过引用或者指针访问arraySize，那么arraySize的值始终是1024。可是如果被作为一个指针或者引用传给其他函数进行取值的话，会发现值变成了2048。
示例：不好的例子：强制去掉入参的const属性，导致函数可以对入参进行修改。
```
void setObj(TBase const *obj)
{
    //m_pObj的定义为:
    TBase *m_pObj;
    m_pObj = const_cast<TBase*>(obj);
    m_pObj->value = 123;
}
```  
#### 7.2.7 使用虚函数替换dynamic_cast 
说明：很多刚从C语言转过了的程序员习惯这样的思路：若对象的类型是T1，则做某种处理；若对象的类型是T2，则做另外的处理等等。但C++提供了更好的解决方案：虚函数。
虚函数与dynamic_cast类型转换相比：
1虚函数更安全，不会出现强制转换错的情况；
2虚函数效率更高：用函数指针，避免条件判断；
3虚函数不需要在编码时确定对象的真实类型，而dynamic_cast必须告知要转成的类型，运行时若类型不当返回空指针或者抛异常；
4虚函数适用性更强：虚函数是真正动态绑定；类型转换当增加或删除一个派生类时，dynamic_cast必须增减相应的代码。 

------------------------------------------------
## 8 函数
### 8.1 规则  
#### 8.1.1 内联函数(inline function)小于10行  
说明：内联函数具有一般函数的特性，它与一般函数不同之处只在于函数调用的处理。一般函数进行调用时，要将程序执行权转到被调用函数中，然后再返回到调用它的函数中；而内联函数在调用时，是将调用表达式用内联函数体来替换。
内联函数只适合于只有1～10行的小函数。对一个含有许多语句的大函数，函数调用和返回的开销相对来说微不足道，也没有必要用内联函数实现，一般的编译器会放弃内联方式，而采用普通的方式调用函数。
如果内联函数包含复杂的控制结构，如循环、分支(switch)、try-catch等语句，一般编译器将该函数视同普通函数。
虚函数、递归函数不能被用来做内联函数。 
#### 8.1.2 使用内联函数代替函数宏  
说明：C++中也支持宏的功能，但是宏有其自身固有的缺陷(例如无法对参数进行类型检查)，因此，能使用内联函数的地方，一定不使用宏。
示例：
```  
//较好的例子:
template <class TYPE_T> inline TYPE_T& max(TYPE_T& x, TYPE_T& y) {
 return (x>y)?x:y;
}
```  
```  
//不好的例子:
#define MAX(x,y)((x)>(y)?(x):(y))
```  
例外：一些通用且成熟的应用，如：对new, delete的封装处理，可以保留对宏的使用。
### 8.2 编码建议
#### 8.2.1 内联函数应该放在头文件中声明，并在函数前添加inline关键字  
说明：内联函数的定义对编译器而言必须可见，以便在调用点将函数展开。放在头文件中可以保证对编译器可见，修改或者删除内联函数时，重新编译使用该头文件的所有源文件。
#### 8.2.2 入参尽量用const引用取代指针  
说明：引用比指针更安全，因为它一定非空，且一定不会再指向其他目标；引用不需要检查非法的NULL指针。
如果是基于老平台开发的产品，则优先顺从原有平台的处理方式。
选择const避免参数被修改，让代码阅读者清晰地知道该参数不被修改，可大大增强代码可读性。 
#### 8.2.3 消除未使用函数参数   
说明：检查未使用的函数参数，确认是否需要使用该函数参数，如果不需要直接删除参数名。
当实现接口时，有一些参数没有被引用是相当常见的。编译器会发现未使用的参数，并产生一个警告，有些组件甚至会认为这是一个错误。为避免发生如此情况，将未使用的参数使用/* 参数名 */ 语法将其注释掉。 
#### 8.2.4 尽量少用缺省参数  
说明：使用参数的缺省值仅仅方便函数的使用，没有赋予函数新的功能，但降低函数的可理解。同时，只允许在非虚函数中使用缺省参数, 且必须保证缺省参数的值始终一致。
缺省参数使得拷贝粘贴以前函数调用的代码难以呈现所有参数，当缺省参数不适用于新代码时可能导致重大问题。 
#### 8.2.5 尽量少用函数指针   
说明：不少代码中还是用函数指针来实现一些功能扩展（如封装），但函数指针难以理解和难以维护，建议使用C++中派生与继承的基本用法，少用函数指针。  
#### 8.2.6 编写简短的函数 
说明：长函数有时是合理的，因此并不硬性限制函数的长度。如果函数超过40行，可以思索一下能不能在不影响程序结构的前提下对其进行分割。
即使一个长函数现在工作的非常好，一旦有人对其修改，有可能出现新的问题，甚至导致难以发现的bug。使函数尽量简短，以便于他人阅读和修改代码。
在处理代码时，你可能会发现复杂的长函数。不要害怕修改现有代码：如果证实这些代码使用调试起来很困难，或者你只需要使用其中的一小段代码，考虑将其分割为更加简短并易于管理的若干函数。 

------------------------------------------------
## 9 类  
类是面向对象设计的基础，一个好的类应该职责单一，接口清晰、少而完备，类间低耦合、类内高内聚，并且很好地展现封装、继承、多态、模块化等特性。 
### 9.1 原则  
#### 9.1.1 类设计：类职责单一  
说明：类应该职责单一。如果一个类的职责过多，往往难以设计、实现、使用、维护。
用小类代替巨类。小类更易于编写，测试，使用和维护。用小类体现简单设计的概念；巨类会削弱封装性，巨类往往承担过多职责，试图提供“完整”的解决方案，但往往难以真正成功。如果一个类有10个以上数据成员，类的职责可能过多。  
#### 9.1.2 类设计：隐藏信息  
说明：封装是面向对象设计和编程的核心概念之一。隐藏实现的内部数据，减少调用者代码与具体实现代码之间的依赖。
1尽量减少全局和共享数据；
2禁止成员函数返回成员可写的引用或者指针；
3将数据成员设为私有的(struct除外)，并提供相关存取函数；  
4避免为每个类数据成员提供访问函数；
5运行时多态，将内部实现(派生类提供)与对外接口(基类提供)分离。  
#### 9.1.3 类设计：尽量使类的接口正交、少而完备  
说明：应该围绕一个核心去定义接口、提供服务、与其他类合作，从而易于实现、理解、使用、测试和维护。接口函数功能正交，尽量避免一个接口功能覆盖另一个接口功能。接口函数太多，会难以理解、使用和维护。如果一个类包含20个以上的非私有成员函数，类的接口可能不够精简。  
#### 9.1.4 类继承：用组合代替继承
继承是面向对象语言的一个基本特性。理解各种继承的含义：“public继承”意味"是...一个"，纯虚函数只继承接口，一般的虚函数继承接口并提供缺省实现，非虚函数继承接口和实现但不允许修改。
继承的层次过多导致理解困难；多重继承会显著增加代码的复杂性，还会带来潜在的混淆。
说明：继承和组合都可以复用和扩展现有的能力。如果组合能表示类的关系，那么优先使用组合。
继承实现比较简单直观，但继承在编译时定义，无法在运行时改变；继承对派生类暴露了基类的实现细节，使派生类与基类耦合性非常强。一旦基类发生变化，派生类随着变化，而且因为派生类无法修改基类的非虚函数，导致修改基类会影响到各个派生类。而组合的灵活性较高，代码耦合小，所以优先考虑组合。
但是并非绝对，往往组合和继承是一起使用的，例如组合的元素是抽象的，通过实现抽象来修改组合的行为。
继承在一般情况下有两类：实现继承(implementation inheritance)和接口继承(interface inheritance)，尽可能不要使用实现继承而考虑用组合替代。
接口继承：只继承成员函数的接口（也就是声明），例如纯虚（pure virtual）函数；实现继承：继承成员函数的接口和实现，例如虚函数同时继承接口和缺省实现，又能够覆写它们所继承的实现；非虚函数继承接口，强制性继承实现。
示例：组合是指一个类型嵌入另一个类型的成员变量，即"有一个"或"由...来实现"。例如：
```
class Address{ ... }; //某人居住之处
class PhoneNumber{ ... }; //某人电话号码
class Person
{
private:
    string name; //组合成员变量
    Address address; //同上
    PhoneNumber voiceNumber; //同上
    PhoneNumber faxNumber; //同上
};
```
#### 9.1.5 类继承：避免使用多重继承  
说明：相比单继承，多重实现继承可重用更多代码；但多重继承会显著增加代码的复杂性，程序可维护性差，且父类转换时容易出错，所以除非必要，不要使用多重继承，使用组合来代替。
多重继承中基类都是纯接口类，至多只有一个类含有实现。  
#### 9.1.6 重载：尽量不重载操作符，保持重载操作符的自然语义 
说明：重载操作符要有充分理由,而且不要改变操作符原有语义，例如不要使用 ‘+’ 操作符来做减运算。 
操作符重载令代码更加直观，但也有一些不足：  
1混淆直觉，误以为该操作和内建类型一样是高性能的，忽略了性能降低的可能；  
2问题定位时不够直观，按函数名查找比按操作符显然更方便。
3重载操作符如果行为定义不直观(例如将‘+’ 操作符来做减运算)，会让代码产生混淆。  
4赋值操作符的重载引入的隐式转换会隐藏很深的bug。可以定义类似Equals()、CopyFrom()等函数来替代=,==操作符。  
### 9.2 规则
#### 9.2.1 模块间对外接口类不要暴露私有和保护成员  
说明：对外接口类暴露受保护或者私有成员则破坏了封装，一旦因为类的设计变更(增加，删除，修改内部成员)会导致关联组件或系统的代码重新编译，从而增加系统编译时间，也产生了二进制兼容问题，导致关联升级和打补丁。所以除非必要，不要在接口类中暴露私有和保护成员。
有如下几种做法：  
1使用纯虚类作为接口类，用实现类完成实现，使用者只看到接口类，这种做法缺点是：代码结构相对复杂；新增接口必须放在原有接口后面，不能改变原有接口的顺序。否则，因为虚函数表的原因，会导致客户代码重新编译。
2接口类使用PIMPL模式(只有一个指向实现类指针的私有数据成员)，所有私有成员都封装在实现类中(实现类可以不暴露为头文件，直接放在实现文件中)。  
代码结构简单，容易理解。
可以节省虚函数开销，但是有间接访问开销。
修改实现不会导致客户代码重新编译。
```
class Interface
{
public:
    void function();
private:
    Implementation* impl_;
};

class Implementation
{
public:
    int i;
    int j;
};

void Interface:: function ()
{
    ++impl_->i;
}
```  
#### 9.2.2 避免成员函数返回成员可写的引用或者指针  
说明：破坏了类的封装性，对象本身不知道的情况下对象的成员被修改。  
#### 9.2.3 禁止类之间循环依赖   
说明：循环依赖会导致系统耦合度大大增加，所以类之间禁止循环依赖。类A依赖类B，类B依赖类A。
出现这种情况需要对类设计进行调整，引入类C：  
升级：将关联业务提到类C，使类C依赖类A和类B，来消除循环依赖
    降级：将关联业务提到类C，使类A和类B都依赖类C，来消除循环依赖。
示例：类Rectangle和类Window互相依赖
``` 
class Rectangle
{
public:
    Rectangle(int x1, int y1, int x2, int y2);
    Rectangle(const Window& w);
};
class Window
{
public:
    Window(int xCenter, int yCenter, int width, int height);
    Window(const Rectangle& r); 
};
``` 
可以增加类BoxUtil做为转换，不用产生相互依赖
``` 
class BoxUtil
{
public:
    static Rectangle toRectangle(const Window& w);
    static Window toWindow(const Rectangle& r);
};
``` 
#### 9.2.4 包含成员变量的类，须定义构造函数或者默认构造函数
说明：如果类有成员变量，没有定义构造函数，又没有定义默认构造函数，编译器将自动生成一个构造函数，但编译器生成的构造函数并不会对成员变量进行初始化，对象状态处于一种不确定性。
例外：如果这个类是从另一个类继承下来，且没有增加成员变量，则不用提供默认构造函数。
示例：如下代码没有构造函数，私有数据成员无法初始化：
``` 
class CMessage
{
public:
    void ProcessOutMsg()
    {
     //…
    }
private:
    unsigned int msgid;
    unsigned int msglen; 
    unsigned char *msgbuffer;
};
CMessage msg; //msg成员变量没有初始化
msg.ProcessOutMsg(); //后续使用存在隐患
//因此，有必要定义默认构造函数，如下：
class CMessage {
public:
    CMessage (): 
        msgid(0), 
        msglen (0), 
        msgbuffer (NULL)
    {
    }
 //...
};
```   
#### 9.2.5 为避免隐式转换，将单参数构造函数声明为explicit
说明：单参数构造函数如果没有用explict声明，则会成为隐式转换函数。
示例：
```  
class Foo
{
public:
    explicit Foo(const string &name):m_name(name)
    {
    }
private:
    string m_name;
};
ProcessFoo("zhangsan"); //函数调用时，编译器报错，因为显式禁止隐式转换
```  
定义了Foo::Foo(string &name)，当形参是Foo对象实参为字符串时，构造函数Foo::Foo(string &name)被调用并将该字符串转换成一个Foo临时对象传给调用函数，可能导致非预期的隐式转换。
解决办法：
在构造函数前加上explicit限制隐式转换。
#### 9.2.6 包含资源管理的类应自定义拷贝构造函数、赋值操作符和析构函数 
说明：如果用户不定义，编译器默认会生成拷贝构造函数、赋值操作符和析构函数。自动生成的拷贝构造函数、赋值操作符只是将所有源对象的成员简单赋值给目的对象，即浅拷贝(shallow copy)；自动生成析构函数是空的。这对于包含资源管理的类来说是不够的：比如从堆中申请的资源，浅拷贝会使得源对象和目的对象的成员指向同一内存，会导致资源重复释放。空的析构函数不会释放已申请内存。
如果不需要拷贝构造函数和赋值操作符，可以在声明后加入delete，让它们失效。
示例：如果结构或对象中包含指针，定义自己的拷贝构造函数和赋值操作符以避免野指针。
``` 
class GIDArr
{
public:
    GIDArr()
    {
        iNum = 0;
        pGid = NULL;
    }
    ~GIDArr()
    {
        if (pGid)
        {
            delete [] pGid;
        }
    }
    GIDArr(const GIDArr& rhs) delete;
    GIDArr& operator = (const GIDArr& rhs) delete;
private:
    int iNum;
    char *pGid;
}GIDArr;
``` 
#### 9.2.7 让operator=返回*this的引用 
说明：符合连续赋值的常见用法和习惯。
示例：
``` 
String& String::operator=(const String& rhs)
{
    //...
    return *this; //返回左边的对象
}
string w, x, y, z;
w = x = y = z = "Hello";
``` 
#### 9.2.8 在operator=中检查给自己赋值的情况
说明：自己给自己赋值和普通赋值有很多不同，若不防范会出问题。
示例：
``` 
class String
{
public:
    String(const char *value); 
    ~String();
    String& operator=(const String& rhs);
private:
    char *data;
};
//自赋值，合法
String a;
a=a; 
//不好的例子：忽略了给自己赋值的情况，导致访问野指针
String& String::operator=(const String& rhs)
{
    delete [] data; //删除data
    //分配新内存，将rhs的值拷贝给它
    data = new char[strlen(rhs.data) + 1]; //rhs.data已经删除，变成野指针
    strcpy(data, rhs.data);
    return *this; 
}
//好的例子：检查给自己赋值的情况
String& String::operator=(const String& rhs)
{
    if(this != &rhs)
    {
        delete [] data;
        data = new char[strlen(rhs.data) + 1];
        strcpy(data, rhs.data);
    }
    return *this; 
}
``` 
#### 9.2.9 在拷贝构造函数、赋值操作符中对所有数据成员赋值 
说明：确保构造函数、赋值操作符的对象完整性，避免初始化不完全。  
#### 9.2.10 通过基类指针来执行删除操作时，基类的析构函数设为公有且虚拟的  
说明：只有基类析构函数是虚拟的，才能保证派生类的析构函数被调用。
示例：基类定义中无虚析构函数导致的内存泄漏。
``` 
//如下平台定义了基类A，完成获取版本号的功能。
class A {
public:
    virtual std::string getVersion()=0;
};
``` 
``` 
//产品派生类B，实现其具体功能，其定义如下：
class B:public A {
public:
    B()
    { 
        cout<<"B()"<<endl;
        m_int = new int [100];
    }
    ~B()
    {
        cout<<"~B()"<<endl;
        delete [] m_int;
    }
    std::string getVersion(){ return std::string("hello!");}
private:
    int *m_int;
};
``` 
``` 
//模拟该接口的调用代码如下：
int main(int argc, char* args[])
{
    A *p = new B();
    delete p;
    return 0;
}
``` 
派生类B虽然在析构函数中进行了资源清理，但不幸的是该派生类析构函数永远不会被调用。由于基类A没有定义析构函数，更没有定义虚析构函数，当对象被销毁时，只会调用系统默认的析构函数，故导致内存泄漏。
#### 9.2.11 避免在构造函数和析构函数中调用虚函数   
说明：在构造函数和析构函数中调用虚函数，会导致未定义的行为。
在C++中，一个基类一次只构造一个完整的对象。
示例：类BaseA是基类，DeriveB是派生类
``` 
class BaseA //基类BaseA
{ 
public: 
    BaseA();
    virtual void log() const=0; //不同的派生类调用不同的日志文件
};
BaseA::BaseA() //基类构造函数
{
    log(); //调用虚函数log
}
class DeriveB:public BaseA //派生类
{ 
public:
    virtual void log() const; 
};
``` 
当执行如下语句：
``` 
DeriveB B;
``` 
会先执行DeriveB的构造函数，但首先调用BaseA的构造函数，由于BaseA的构造函数调用虚函数log，此时log还是基类的版本，只有基类构造完成后，才会完成派生类的构造，从而导致未定义的行为。
同样的道理也适用于析构函数。
#### 9.2.12 使用public继承而不是protected/private继承  
说明：public继承与private继承的区别：
private继承体现"由...来实现"的关系。编译器不会把private继承的派生类转换成基类，也就是说，私有继承的基类和派生类没有"是...一个"的关系。 
public继承体现"是...一个"的关系，即类B public继承于类A，则B的对象就是A的对象，反之则不然。例如“白马是马，但马不是白马”。对继承而言，努力做到"是...一个"的关系，否则使用组合代替。 
private继承意味"由...来实现"，它通常比组合的级别低，与组合的区别：
1private继承可以访问基类的protected成员，而组合不能。
2 private继承可以重新定义基类的虚函数，而组合不能。
尽量用组合代替private继承，因为private继承不如组合简单直观，且容易和public继承混淆。  
#### 9.2.13 继承层次不超过4层 
说明：当继承的层数超过4层时，对软件的可维护性大大降低，可以尝试用组合替代继承。 
#### 9.2.14 虚函数绝不使用缺省参数值  
说明：在C++中，虚函数是动态绑定的，但函数的缺省参数却是在编译时就静态绑定的。这意味着你最终执行的函数是一个定义在派生类，但使用了基类中的缺省参数值的虚函数。因此只要在基类中定义缺省参数值即可，绝对不要在派生类中再定义缺省参数值。
示例：虚函数display缺省参数值strShow 是由编译时刻决定的，而非运行时刻，没有达到多态的目的：
``` 
class Base
{
public:
    virtual void display(const std::string& strShow = "I am Base class !")
    {
        std::cout << strShow << std::endl;
    }
    virtual ~Base(){}
};
class Derive: public Base
{
public:
    virtual void display(const std::string& strShow = "I am Derive class !")
    {
        std::cout << strShow << std::endl; 
    }
    virtual ~Derive(){}
};
``` 
``` 
int main()
{
    Base* pBase = new Derive();
    Derive* pDerive = new Derive();
    pBase->display(); //程序输出结果: I am base class ! 而期望输出：I am Derive class !
    pDerive->display();//程序输出结果: I am Derive class !
    delete pBase;
    delete pDerive;
    return 0;
};
``` 
#### 9.2.15 绝不重新定义继承而来的非虚函数  
说明：因为非虚函数无法实现动态绑定，只有虚函数才能实现动态绑定：只要操作基类的指针，即可获得正确的结果。
示例：pB->mf()和pD->mf()两者行为不同。
``` 
class B {
public:
    void mf();
    //...
};
class D:public B
{ 
public:
    void mf();
    //...
};
D x; //x is an object of type D
B *pB = &x; //get pointer to x
D *pD = &x; //get pointer to x
pB->mf(); //calls B::mf
pD->mf(); //calls D::mf
``` 
#### 9.2.16 仅在输入参数类型不同、功能相同时重载函数 
说明：使用重载，导致在特定调用处很难确定到底调用的是哪个函数；当派生类只重载函数的部分变量，会对继承语义产生困惑，造成不必要的费解。
如果函数的功能不同，考虑让函数名包含参数信息，例如，使用AppendName()、AppendID()而不是Append()。
### 9.3 编码建议  
#### 9.3.1 将数据成员设为私有的(struct除外)，并提供相关存取函数  
说明：信息隐藏是良好设计的关键，应该将所有数据成员设为私有，精确的控制成员变量的读写，对外屏蔽内部实现。否则意味类的部分状态可能无法控制、无法预测，原因是：  
1非private成员破坏了类的封装性，导致类本身不知道其数据成员何时被修改；
2任何对类的修改都会延伸影响到使用该类的代码。
将数据成员私有化，必要时提供相关存取函数，如定义变量foo_及取值函数foo()、赋值操作符set_foo()。 
存取函数一般内联在头文件中定义成内联函数。如果外部没有需求，私有数据成员可以不提供存取函数，以达到隐藏和保护的目的。不要通过存取函数来访问私有数据成员的地址。
#### 9.3.2 使用PIMPL模式，确保私有成员真正不可见   
说明：C++将私有成员成员指定为不可访问，但还是可见的，可以通过PIMPL惯用法使私有成员在当前类的范围中不可见。PIMPL主要是通过前置声明，达到接口与实现的分离的效果，降低编译时间，降低耦合。
示例：
``` 
class Map
{
private:
    struct Impl;
    shared_ptr<Impl> pimpl_;
};
```   
#### 9.3.3 拷贝构造函数和赋值操作符的参数定义成const引用类型  
说明：拷贝构造函数和赋值操作符不可以改变它所引用的对象。
#### 9.3.4 在析构函数中集中释放资源   
说明：使用析构函数来集中处理资源清理工作。如果在析构函数之前，资源被释放（如release函数），请将资源设置为NULL，以保证析构函数不会重复释放。
#### 9.3.5 避免派生类中定义与基类同名但参数类型不同的函数  
说明：参数类型不同的函数实际是不同的函数。
示例：如下三个类，类之间继承关系如下：类Derive2继承类Derive1，类Derive1继承类Base。
三个类之中均实现了FOO函数，定义如下：
``` 
Base类：virtual long FOO(const A , const B , const C)=0;
Derive1类：long FOO(const A , const B , const C);
Derive2类：long FOO(const A , B , const C);
``` 
代码中存在如下的调用：
``` 
Base* baseptr = new Derive2();
baseptr -> FOO(A,B,C);
``` 
代码原意是期望通过如上的代码调用Derive2::FOO函数，但是由于Derive2::FOO与Base::FOO的参数类型不一致，Derive2::FOO对Base类来说不可见，导致实际运行的时候，调用到Derive1::FOO，出现调用错误。使得代码逻辑异常。
解决方案：确保派生类Derive2::FOO定义和Base::FOO一致。
#### 9.3.6 派生类重定义的虚函数也要声明virtual关键字  
说明：当重定义派生的虚函数时，在派生类中明确声明其为virtual。如果遗漏virtual声明，阅读者需要检索类的所有祖先以确定该函数是否为虚函数。
#### 9.3.7 使用重载以避免隐式类型转换  
说明：隐式转换常常创建临时变量；如果提供类型精确匹配的重载函数，不会导致转换。
示例：
```
class String 
{
    //…
    String( const char* text ); //允许隐式转换
};
bool operator==( const String&, const String& );
```
```
//…代码中某处…
if( someString == "Hello" ) {... }
```
上述例子中编译器进行隐式转换，好像someString == String( "Hello")一样，形成浪费，因为并不需要拷贝字符。使用操作符重载即可消除这种隐式转换：
```
bool operator==( const String& lhs, const String& rhs ); //#1
bool operator==( const String& lhs, const char* rhs ); //#2
bool operator==( const char* lhs, const String& rhs ); //#3
``` 
#### 9.3.8 C/C++混用时，避免重载接口函数 
说明：目前很多产品采用C模块与C++模块混合的方式，在这个情况下，应该避免模块之间接口函数的重载。比如：传递给用C语言实现的组件的函数指针。
```
stPdiamLiCallBackFun.pfCreateConn = PDIAM_COM_CreatConnect;
stPdiamLiCallBackFun.pfDeleteConn = PDIAM_COM_DeleteConnect;
stPdiamLiCallBackFun.pfSendMsg = PDIAM_COM_SendData;
stPdiamLiCallBackFun.pfRematchConn = PDIAM_COM_RematchConn;
stPdiamLiCallBackFun.pfSuCloseAcceptSocket = PDIAM_COM_CloseAcceptSocket;
//注册系统底层通讯函数
ulRet = DiamRegLiFunc(&stPdiamLiCallBackFun);
if (DIAM_OK != ulRet)
{
    return PDIAM_ERR_FAILED_STACK_INIT;
}
```
上面的代码中，由于组件通过C语言实现，如果重载PDIAM_COM_CreatConnect等函数，将会导致该组件无法初始化。  

------------------------------------------------
## 10 C++其他特性
### 10.1 模板 
模板可以衍生出一系列的类和函数，这是一种形式的代码复用。但要注意，这种形式的复用是源代码级，而不是目标代码级的。也就是说，对模板的每一次实例化都会产生一份新的源代码。与此相反，继承允许复用基类的大部分目标代码。
滥用模板会造成三个后果：第一，代码规模的过度膨胀；第二，当修改模板时，很难预料是否会对原先正常工作的代码造成不良影响；第三，很难确保模板所有可能的合法实例化都能正常工作。所以模板的使用要仔细且有节制。
#### 10.1.1 谨慎使用模板，只使用模板的基础特性  
说明：模板对编译器的要求很高，当前对模板100%支持的编译器几乎没有，因此，使用前应作测试，特别是涉及偏特化，模板参数等高级特性时。
模板的错误提示比较难懂，产生的错误要映射回模板后才能显示给编程者看，但映射毕竟不是错代码本身，所以有时很难看懂，有时甚至失真，对于人员素质要求也高，增加了维护难度。
#### 10.1.2 注意使用模板的代码膨胀 
说明：模板会为每个类型产生一个实例，如果使用不当，会产生过多实例，特别是根据常量实例化时。
#### 10.1.3 模板类型应该使用引用或指针  
说明：实例化和参数传递复杂类型(结构体，对象)，传值的代价很高；引用和指针可以提高效率。 
#### 10.1.4 模板如果有约束条件，请在模板定义处显式说明  
说明：编译对模板的检查较弱，很难保证检察所有错误，因此进行显式说明可以减少模板使用错误。 
#### 10.1.5 两个模块之间接口中尽量不要暴露模板 
说明：因为在编译器优化选项打开的情况下，其编译的符号为不确定，导致依赖。 
### 10.2 其他  
#### 10.2.1 避免使用友元 
说明：友元扩大了 (但没有打破) 类的封装边界。友元会导致类间强耦合，打破封装，暴露出具体实现，从而使友元和类的实现紧耦合；友元不可继承，降低可继承性。
例外：某些情况下，相对于将类成员声明为public，使用友元是更好的选择，尤其是你只允许另一个类访问该类的私有成员时。
#### 10.2.2 避免使用RTTI 
说明：RTTI允许在运行时识别对象的类型。使用RTTI很容易违反“开放封闭原则”。如果要根据派生类的类型来确定执行不同逻辑代码, 虚函数无疑更合适，在对象内部就可以处理类型识别问题；如果要在对象外部的代码中判断类型, 考虑使用双重分派方案, 如访问者模式，在对象本身之外确定类的类型。所以，不建议使用RTTI，除非在一些特定场合如某些单元测试中会用到。 
#### 10.2.3 使用sizeof(变量)而不是sizeof(类型) 
说明：使用 sizeof(varname)，当代码中变量类型改变时会自动更新。
```
struct DATA data;
memset(&data, 0, sizeof(data));
memset(&data, 0, sizeof(DATA)); //当data改为其他类型时，出错。
```
另外，对数组来说，sizeof(数组变量) 并不一定是元素的个数，元素个数是sizeof(数组变量)/sizeof(数组变量[0])。
#### 10.2.4 只在定义移动构造函数与移动赋值操作时使用右值引用，不要使用 std::forward 
说明：右值引用是一种只能绑定到临时对象的引用的一种，其语法与传统的引用语法相似。例如，void f(string&& s); 声明了一个其参数是一个字符串的右值引用的函数。只在定义移动构造函数与移动赋值操作时使用右值引用，不要使用 std::forward 功能函数。你可能会使用 std::move 来表示将值从一个对象移动而不是复制到另一个对象。
右值引用是一个相对比较新的特性 (由 C++11 引入), 它尚未被广泛理解。类似引用崩溃，移动构造函数的自动推导这样的规则都是很复杂的。
#### 10.2.5 对于迭代器和其他模板对象使用前缀形式 (++i) 的自增,、自减运算符 
说明：对于变量在自增 (++i 或 i++) 或自减 (--i 或 i--) 后表达式的值又没有没用到的情况下，需要确定到底是使用前置还是后置的自增 (自减)。
不考虑返回值的话，前置自增 (++i) 通常要比后置自增 (i++) 效率更高。因为后置自增 (或自减) 需要对表达式的值 i 进行一次拷贝。如果 i 是迭代器或其他非数值类型，拷贝的代价是比较大的。既然两种自增方式实现的功能一样，应当尽量使用前缀形式。
即，对简单数值 (非对象)，两种都无所谓。对迭代器和模板类型，使用前置自增 (自减)。
#### 10.2.6 用 constexpr 来定义真正的常量，或实现常量初始化 
说明：变量可以被声明成 constexpr 以表示它是真正意义上的常量，即在编译时和运行时都不变。函数或构造函数也可以被声明成 constexpr，以用来定义 constexpr 变量。 constexpr 可以定义浮点式的真・常量，不用再依赖字面值了；也可以定义用户自定义类型上的常量；甚至也可以定义函数调用所返回的常量。靠 constexpr 特性，方才实现了 C++ 在接口上打造真正常量机制的可能。
#### 10.2.7 0, nullptr 和 NULL
说明：整数用 0, 实数用 0.0, 指针用 nullptr 或 NULL, 字符 (串) 用 '\0'。
整数用 0, 实数用 0.0, 这一点是毫无争议的。
对于指针 (地址值), 到底是用 0, NULL 还是 nullptr。 
C++11 项目用 nullptr; C++03 项目则用 NULL, 毕竟它看起来像指针。实际上，一些 C++ 编译器对 NULL 的定义比较特殊，可以输出有用的警告，特别是 sizeof(NULL) 就和 sizeof(0) 不一样。字符 (串) 用 '\0', 不仅类型正确而且可读性好。
#### 10.2.8 auto  
说明：auto 只能用在局部变量里用。别用在文件作用域变量，命名空间作用域变量和类数据成员里。永远别列表初始化 auto 变量。
#### 10.2.9 适当使用 lambda 表达式。别用默认 lambda 捕获，所有捕获都要显式写出来  
说明：禁用默认捕获，捕获都要显式写出来。打比方，比起 [=](int x) {return x + n;}, 您该写成 [n](int x) {return x + n;} 才对，这样读者也好一眼看出 n 是被捕获的值。匿名函数始终要简短，如果函数体超过了五行，那么还不如起名（注：即把 lambda 表达式赋值给对象），或改用函数。如果可读性更好，就显式写出 lambda 的尾置返回类型，就像auto。 

------------------------------------------------
## 11 命名约定 
最重要的一致性规则是命名管理。命名的风格能让我们在不需要去查找类型声明的条件下快速地了解某个名字代表的含义：类型，变量，函数，常量，宏，等等，甚至，我们大脑中的模式匹配引擎非常依赖这些命名规则。
命名规则具有一定随意性，但相比按个人喜好命名，一致性更重要，所以无论你认为它们是否重要，规则总归是规则。
### 11.1 通用命名规则 
#### 11.1.1 函数命名，变量命名，文件命名要有描述性；少用缩写
说明：尽可能使用描述性的命名，别心疼空间，毕竟相比之下让代码易于新读者理解更重要。不要用只有项目开发者能理解的缩写，也不要通过砍掉几个字母来缩写单词。
```
int price_count_reader;    // 无缩写
int num_errors;            // "num" 是一个常见的写法
int num_dns_connections;   // 人人都知道 "DNS" 是什么
int n;                     // 毫无意义
int nerr;                  // 含糊不清的缩写
int n_comp_conns;          // 含糊不清的缩写
int wgc_connections;       // 只有贵团队知道是什么意思
int pc_reader;             // "pc" 有太多可能的解释了
int cstmr_id;              // 删减了若干字母
```
注意，一些特定的广为人知的缩写是允许的，例如用i表示迭代变量和用 T 表示模板参数。
模板参数的命名应当遵循对应的分类：类型模板参数应当遵循类型命名的规则，而非类型模板应当遵循变量命名的规则。 
### 11.2 文件命名 
文件名要全部小写，可以包含下划线 (_) 或连字符 (-)，依照项目的约定，如果没有约定，那么“_”更好。
可接受的文件命名示例：
my_useful_class.cpp
my-useful-class.cpp
myusefulclass.cpp
myusefulclass_test.cpp
不要使用已经存在于/usr/include下的文件名(注：即编译器搜索系统头文件的路径)，如db.h。
通常应尽量让文件名更加明确. http_server_logs.h 就比 logs.h 要好。定义类时文件名一般成对出现，如 foo_bar.h 和 foo_bar.cpp。
内联函数必须放在 .h 文件中。如果内联函数比较短，就直接放在 .h 中。
### 11.3 类型命名 
#### 11.3.1 类型名称的每个单词首字母均大写，不包含下划线：MyExcitingClass, MyExcitingEnum 
说明：所有类型命名 —— 类，结构体，类型定义 (typedef)，枚举，类型模板参数 —— 均使用相同约定，即以大写字母开始，每个单词首字母均大写，不包含下划线。例如：
```
// 类和结构体
class UrlTable { ...
class UrlTableTester { ...
struct UrlTableProperties { ...
```
### 11.4 变量命名  
#### 11.4.1 变量 (包括函数参数) 和数据成员名小写，单词首字母可大写，类的成员变量以m_开头 
### 11.5 常量命名 
#### 11.5.1 声明为constexpr或const的变量，或在程序运行期间其值始终保持不变的，命名时以“k”开头，大小写混合 
说明：所有具有静态存储类型的变量(例如静态变量或全局变量，参见存储类型)都应当以此方式命名。对于其他存储类型的变量，如自动变量等，这条规则是可选的。如果不采用这条规则，就按照一般的变量命名规则。
```
const int kDaysInAWeek = 7;
```
### 11.6 函数命名 
#### 11.6.1 常规函数使用大小写混合，取值和设值函数则要求与变量名匹配 
说明：一般来说，函数名的每个单词首字母大写(即“驼峰变量名”或“帕斯卡变量名”)，没有下划线。对于首字母缩写的单词，更倾向于将它们视作一个单词进行首字母大写(例如，写作 StartRpc() 而非 StartRPC())。
```
AddTableEntry()
DeleteUrl()
OpenFileOrDie()
```
(同样的命名规则同时适用于类作用域与命名空间作用域的常量，因为它们是作为API的一部分暴露对外的，因此应当让它们看起来像是一个函数，因为在这时，它们实际上是一个对象而非函数的这一事实对外不过是一个无关紧要的实现细节。)
取值和设值函数的命名与变量一致。一般来说它们的名称与实际的成员变量对应，但并不强制要求。例如int count()与void setCount(int count)。
### 11.7 命名空间命名 
命名空间以小写字母命名。最高级命名空间的名字取决于项目名称。要注意避免嵌套命名空间的名字之间和常见的顶级命名空间的名字之间发生冲突。
顶级命名空间的名称应当是项目名或者是该命名空间中的代码所属的团队的名字。命名空间中的代码，应当存放于和命名空间的名字匹配的文件夹或其子文件夹中。
注意不使用缩写作为名称的规则同样适用于命名空间。命名空间中的代码极少需要涉及命名空间的名称，因此没有必要在命名空间中使用缩写。
要避免嵌套的命名空间与常见的顶级命名空间发生名称冲突。由于名称查找规则的存在，命名空间之间的冲突完全有可能导致编译失败。尤其是，不要创建嵌套的std命名空间。建议使用更独特的项目标识符(websearch::index, websearch::index_util)而非常见的极易发生冲突的名称(比如websearch::util)。
对于internal命名空间，要当心加入到同一internal命名空间的代码之间发生冲突(由于内部维护人员通常来自同一团队，因此常有可能导致冲突)。在这种情况下，请使用文件名以使得内部名称独一无二(例如对于frobber.h,使用 websearch::index::frobber_internal)。
### 11.8 枚举命名 
#### 11.8.1 枚举的命名应当和常量或宏一致：kEnumName 或是 ENUM_NAME 
说明：单独的枚举值应该优先采用常量的命名方式。但宏方式的命名也可以接受。枚举名UrlTableErrors (以及 AlternateUrlTableErrors)是类型，所以要用大小写混合的方式。
```
enum UrlTableErrors {
    kOK = 0,
    kErrorOutOfMemory,
    kErrorMalformedInput,
};
enum AlternateUrlTableErrors {
    OK = 0,
    OUT_OF_MEMORY = 1,
    MALFORMED_INPUT = 2,
};
```
### 11.9 宏命名 
说明：参考预处理宏；通常不应该使用宏。如果不得不用，其命名像枚举命名一样全部大写，使用下划线：
```
#define ROUND(x) ...
#define PI_ROUNDED 3.0
```

------------------------------------------------
## 12 资源分配和释放 
### 12.1 原则 
#### 12.1.1 明确产品动态内存的申请与释放原则 
说明：之所以存在大量内存问题，主要原因是申请与释放内存的规则混乱：
1申请内存后，传入子程序中，由子程序使用并释放。
2由子程序申请内存并返回父程序，层层调用后在某一个函数内释放。
内存申请与释放一般原则：
1对象在退出其作用域时，就应该立即被释放，而且要做到：谁申请，谁释放。
2函数内分配的内存，函数退出之前要释放，避免跨函数释放。
3类中数据成员的内存，在析构函数中确认并释放。
4全局变量、静态变量的内存空间则在进程退出时，或相应的共享库被卸载时，由操作系统回收。
5如果程序分支很多或内存资源的分配与释放不在同一个地方，要考虑使用RAII等资源跟踪管理技术。
### 12.2 规则 
#### 12.2.1 明确operator new的行为和检查策略  
说明：当operator new无法满足某一内存分配需求时，默认会抛异常，也可以返回空指针(通过编译选项设置)。在申请内存后，要立即检查指针是否为NULL或进行异常处理。
示例：捕获异常来处理申请内存失败情况：
```
char* pBuffer = NULL;
try
{ 
    pBuffer = new char[BUFFER_SIZE]; 
} 
catch (...) 
{ 
    pBuffer = NULL;
    return EF_FAIL; 
} 
```
或进行非空判断：
```
char* pBuffer = new char[BUFFER_SIZE];
if (NULL == pBuffer)
{
    return ER_FAIL;
}
```
#### 12.2.2 释放内存后，要立即将指针设置为NULL，防止产生野指针  
说明：free或delete释放内存后，立即将指针设置为NULL，防止产生“野指针”。这种判断最好能够封装起来。
示例：
```
char* pBuffer = new char[BUFFER_SIZE];
//…
delete [] pBuffer;
pBuffer = NULL;
```
#### 12.2.3 单个对象释放使用delete，数组对象释放使用delete []  
说明：单个对象删除使用delete， 数组对象删除使用delete []。
原因：
1调用new所包含的动作：从系统中申请一块内存，对象调用相应的构造函数。
2调用new[n]所包含的动作：申请可容纳n个对象外加一点内存来保存数组的元素的数量；调用n次构造函数初始化这块内存中的n个对象。
3调用delete所包含的动作：对象调用相应的析构函数；将内存归还系统。
4调用delete[]所包含的动作：从new[]将找出的n值；调用n次相应的析构函数；将内存归还给系统。
示例：
```
std::string *string = new std::string;
std::string *stringArray = new std::string[100];
delete string;
string = NULL;
delete [] stringArray;
stringArray = NULL;
```
如果使用delete stringArray；会导致stringArray指向的100个string对象中的99个未被销毁，因为它们的析构函数根本没有被调用，并且结果是不可预测的，编译器不同，结果也不同。
#### 12.2.4 释放结构(类)指针时，首先释放其成员指针的内存空间  
示例：下面是一段有内存泄漏的产品代码：
```
struct STORE_BUF_S
{
    ULONG ulLen;
    UCHAR *pcData;
}STORE_BUF_T;
void func()
{
    STORE_BUF_T *pstStorageBuff = NULL;
    //申请结构内存….
    //程序处理…
    free(pstStorageBuff);
    return;
 }
```
先删除了pstStorageBuff，pstStorageBuff->pcData永远不可能被删除了。删除结构指针时，必须从底层向上层顺序删除。即：
```
free (pstStorageBuff->pcData);
free(pstStorageBuff);
```
#### 12.2.5 释放指针数组时，首先释放数组每个元素指针的内存  
说明：在释放指针数组时，确保数组中的每个元素指针是否已经被释放了，这样才不会导致内存泄漏。
示例：
```
struct dirent **namelist;
int n = scandir(path.c_str(), &namelist, 0, alphasort);//【1】
int i = 0;
for(i ; i < n; ++i)
{
    string name = namelist[i]->d_name;
    free(namelist[i]); //【2】
    if(name != ".." && name != ".")
    {
        //.........
        ++fileNum;
        if(MAX_SCAN_FILE_NUM == fileNum )//MAX_SCAN_FILE_NUM=1000
       {
           break;
       }
    } 
 }
free(namelist); //【3】
return;
```
从上面的代码可以看是指针数组namelist由系统函数进行分配内存(如【1】所示)，内存释放时时分别由【2】释放数组单个元素和【3】释放数组本身内存一起完成的。但是中间有个条件，每次只取1000个文件，如果目录下的文件大于1000就跳出，后面的就不会再处理(【2】没有执行到)。当本地目录下文件数比较小，小于等于1000时没有内存泄漏；而当本地目录下的文件大于1000时，就会导致内存泄漏。所以释放指针数组时，请注意首先释放其每个元素的内存空间。
正确的做法是在【3】之前加上：
```
for(int j = i ; j < n; ++j)
{
    free(namelist[i]); 
}
```
#### 12.2.6 不要返回局部对象指针 
说明：局部对象在定义点构造，在同一作用域结束时立即被销毁。
示例：
```
char* GetParameter ()
{
    CDBConnect DBConnect;
    //………………..
    return DBConnect.GetString("ParamValue");
}
```
由于对象DBConnect已经析构，对应的指针已经被释放，从而后续访问非法内存，导致系统coredump。
#### 12.2.7 不要强制关闭线程  
说明：线程被强制关闭，导致线程内部资源泄漏。用事件或信号量通知线程，确保线程调用自身的退出函数。线程死锁需要强制关闭的情况除外。
示例：强制关闭线程，导致线程资源泄漏。
```
CShakeHand::CShakeHand()
{
    m_hdShakeThreadrecv = CreateThread(NULL, 0, 
    (LPTHREAD_START_ROUTINE)ThreadProc_ShakeHands,
    this, NULL, &m_ulShakeThreadID);
}
CShakeHand::~CShakeHand()
{
    TerminateThread(m_hdShakeThreadrecv, 0); //强制关闭
    CloseHandle(m_hdShakeThreadrecv);
}
```
### 12.3 编码建议 
#### 12.3.1 使用new, delete的封装方式来分配与释放内存  
说明：推荐使用如下宏，可以在一定程度上避免使用空指针，野指针的问题。
```
#define AOTO_NEW(var, classname) \
 do { \
 try \
{ \
 var = new classname; \
} \
 catch (...) \
{ \
 var = NULL; \
} \
 break; \
 } while(0)
//(1) 该宏会将var置为NULL, 所以调用该宏之后, 不再需要置var为NULL
//(2) AOTO_DELETE宏与NEW对应, 用来释放由AOTO_NEW分配的对象
// 注意: 如果以数组方式分配对象(见对HW_NEW的描述), 则必须使用宏AOTO_DELETE_A
// 来释放, 否则可能导致问题
#define AOTO_DELETE(var) \
 do \
{ \
 if (var != NULL) \
{ \
 delete var; \
 var = NULL; \
} \
 break; \
} while(NULL == var)
//(1) 这个宏用来删除一个由AOTO_NEW分配的数组, 删除之后也会将var置为NULL
#define AOTO_DELETE_A(var) \
 do \
{ \
 if (var != NULL) \
{ \
 delete []var; \
 var = NULL; \
} \
 break; \
} while(NULL == var)
```
直接使用AOTO_DELETE，AOTO_DELETE_A宏来释放指针内存空间，就不会出现遗忘将指针置为NULL了。
#### 12.3.2 避免在不同的模块中分配和释放内存  
说明：在一个模块中分配内存，却在另一个模块中释放它，会使这两个模块之间产生远距离的依赖，使程序变得脆弱。
模块在C++是一个不清晰的概念，小到一个类，大到一个库。如果在不同的类之间分配、释放内存，需要考虑两个类的初始化、销毁顺序；如果在不同的库之间分配、释放内存，需要考虑两个库的加载或卸载顺序。这种远距离的依赖，容易导致遗漏和重复操作，引发严重问题。
有时，在通信机制下，两个实体(如线程)之间交换数据或消息，考虑到程序执行效率，不会采用拷贝的方式交换数据，而是通过指针交换数据，仍然会在不同位置分配、释放内存。这种情况下，只有数据交换成功以后，才会由对方负责释放，否则应遵循“谁申请、谁释放”的原则。为了降低处理复杂性，可以适当地采用RAII或智能指针。
#### 12.3.3 使用 RAII 特性来帮助追踪动态分配 
说明：RAII是“资源获取就是初始化”的缩语(Resource Acquisition Is Initialization)，是一种利用对象生命周期来控制程序资源(如内存、文件句柄、网络连接、互斥量等等)的简单技术。
RAII 的一般做法是这样的：在对象构造时获取资源，接着控制对资源的访问使之在对象的生命周期内始终保持有效，最后在对象析构的时候释放资源。这种做法有两大好处：我们不需要显式地释放资源。对象所需的资源在其生命期内始终保持有效。这样，就不必检查资源有效性的问题，可以简化逻辑、提高效率。
C++类库的智能指针就是其中之一：
auto_ptr是标准C++库提供的一种模板类，使用指针进行初始化，其访问方式也和指针一样。在auto_ptr退出作用域时，所指对象能被隐式的自动删除。这样可以象使用普通指针一样使用auto_ptr，而不用考虑释放问题。注意：auto_ptr的复制会造成它本身的修改，原有的auto_ptr将不再指向任何对象，而由新的auto_ptr接管对象内存，并负责自动删除。因此auto_ptr复制后不能再使用，且不能复制const auto_ptr。
boost库中提供了一种新型的智能指针shared_ptr，它解决了多个指针间共享对象所有权的问题，同时也满足容器对元素的要求，因而可以安全地放入容器中。shared_ptr解决了auto_ptr移动语义的破坏性。
关于auto_ptr与shared_ptr使用请参考C++标准库的相关书籍。
示例：使用RAII不需要显式地释放互斥资源。
```
class My_scope_lock
{
public:
    My_scope_lock(LockType& _lock):m_lock(_lock)
    {
        m_lock.occupy();
    }
    ~My_scope_lock()
    {
        m_lock.relase();
    }
protected:
    LockType m_lock;
}
bool class Data::Update()
{
    My_scope_lock l_lock(m_mutex_lock);
    if()
    {
        return false;
    }
    else
    {
        //execute
    }
    return true;
}
```

------------------------------------------------
## 13 异常和错误处理 
异常是C++语言的一个强大特性，在正确使用之前需要深入了解，以及使用异常代码的上下文。
### 13.1 原则 
#### 13.1.1 减少不必要的异常 
说明：异常对编码技能要求更高，使用中容易出错，首先从安全性角度考虑，尽量少用或者不用异常。
相比返回错误，异常的优点：
1异常可以集中捕捉，错误检测与算法处理相分离，算法逻辑更清晰；而返回错误在每个返回点都要进行检测与错误处理，代码逻辑分散。
2异常的约束更强，用户不能忽略抛出的异常，否则程序默认会被终止，而返回错误则可能被忽略。
异常的缺点也很明显：
1必须检查所有调用点是否可能抛出异常，在抛出后必须正确处理状态和资源变量等，否则可能导致对象状态不正确或者资源泄露等。例如：如果f()依次调用了g()和h()，h抛出被f捕获的异常，g就要当心了，避免资源泄露。  
2必须清楚可能抛出的所有异常，并在合适的地方捕捉，如果遗漏通常会导致程序被终止。
3 使用异常很难评估程序的控制流，代码很难调试。
4目标文件变大，编译时间延长，性能下降。
5若对异常缺乏充分理解，可能会在不恰当的时候抛出异常, 或在不安全的地方从异常中恢复。
适用异常的几个场景：
1出现“不应该出现的”失败，且不能被忽略必须处理，比如分配内存失败。
2上层应用决定如何处理在底层嵌套函数中 “不可能出现的” 失败。
3错误码难以通过函数的返回值或参数返回，比如流。
4许多第三方C++库使用异常，必须在系统边界与第三方C++库结合处使用异常便于跟这些库集成。
5在测试框架中使用异常很方便
#### 13.1.2 建立合理的错误处理策略 
说明：这里所说的错误指运行时错误，并非模块内部的编程和设计错误。模块内部的编程和设计错误应该通过断言标记。
在设计早期确定错误处理策略，包括：鉴别，严重程度，错误检查，错误处理，错误传递，错误报告方案。
错误鉴别：对每个实体(函数、类、模块)，记录该实体内部和外部的不变式、前置条件、后置条件以及它支持的错误安全性保证。
错误严重程度：对于每个错误，标明严重级别。
错误检查：对于每个错误，记载哪些代码负责检查它。
错误处理：对于每个错误，标明负责处理它的代码。
错误报告：对于每个错误，标明合适的报告方法。
错误传递：对每个模块，标明使用什么编程机制传递错误，如C++异常、CORBA异常、返回值。
错误处理策略应该只在模块边界改变。如果模块内外所使用的策略不同，则所有模块入口函数都要直接负责由内到外的策略转换。例如，在一个内部使用C++异常，但提供C语言的API边界的模块中，所有C语言的API必须用catch(„)捕获所有异常并将其转换为错误代码。
#### 13.1.3 离错误最近的地方处理错误或转换错误 
说明：当函数检查到一个自己无法解决的错误，而且会使函数无法继续执行的时候，就应该报告错误。如果缺乏处理的上下文，应该向上传播错误。 
### 13.2 规则
#### 13.2.1 构造和析构函数不能抛出异常  
说明：如果构造和析构函数执行失败则无法安全地撤销和回滚，故这些函数不能向外抛出异常。为了降低复杂性，建议在这类函数中实现最简单的逻辑。
#### 13.2.2 通过传值的方式抛出，通过引用的方式捕获 
说明：抛出异常时，如果抛出指针，谁释放指针就成为问题。捕捉时如果是传值，会存在拷贝，拷贝可能不成功(比如异常是由于内存耗尽造成的)，而且拷贝得不到派生类对象，因为在拷贝时，派生类对象会被切片成为基类对象。  
#### 13.2.3 确保抛出的异常一定能被捕捉到  
说明：异常未被捕捉到，系统的默认行为是终止程序运行，所以要确保程序产生的异常都能被捕捉。 
#### 13.2.4 确保异常发生后资源不泄漏 
说明：异常发生后，当前代码执行序列被打断，需要查看分配的内存、文件和内核句柄等资源是否正确释放，避免资源泄漏，尤其每个可能的返回点是否正确释放资源。
示例：如下代码存在内存泄漏
```
int PortalTransformer::transRLS
{
    RLS_Service* service = NULL;
    NEW( service, RLS_Service );
    parser->adoptDocument();//失败时会抛异常
    //....
    delete service; 
    service ＝NULL; 
    return 0;
}
```
调用adoptDocument出现的异常没有在函数transRLS里面被捕获，而是在父函数里面捕获了异常的派生类。如果发生异常，则NEW( service, RLS_Service )分配的内存泄漏。
解决方案：在函数transRLS里面捕获adoptDocument的异常，如果发生异常，则删除指针service 。
#### 13.2.5 独立编译模块或子系统的外部接口禁止抛异常  
说明：异常处理没有普遍通用的二进制标准，所以不允许跨模块抛异常。
#### 13.2.6 错误发生时，至少确保符合基本保证；对于事务处理，至少符合强保证；对于原子操作，符合无错误保证
说明：基本保证是指访问对象时的状态都是正确的；强保证是对基本保证的增强，不仅要状态正确，而且当失败时状态要回滚到操作前的状态，要么成功要么什么都不做；无错误保证是不能出现失败。
编码中严格遵循此原则，会极大提升程序的健壮性。
符合基本保证的代码示例：如下代码是解析输入流到对象，流抛出异常方式呈报错误
```
void CMessage::Parse(IStream* input)
{
    try
    {
        m_uiMessageLen = input.ReadInteger();//失败会抛出异常
        if (0 == m_uiMessageLen || m_uiMessageLen>MAX_MESSAGE_LEN)
        {
            throw invalid_argument("Invalid message len in CMessage::Parse ");
        }
        m_pMessage = new char[m_uiMessageLen];//失败抛出异常
        input.Read(m_pMessage, m_uiMessageLen);//失败抛出异常
        //.....
    }
    catch (const exception &exp){
        ResetContent();//把对象的所有字段都设置为无效
        throw exp;
    }
    return; 
}
```
上例确保对象字段的值要么都有效要么都无效，不会出现部分有效部分无效的情况，否则必须处理异常被抛出时的对象状态，给调用者带来麻烦，容易遗漏。故接口应该至少符合基本保证。
可以把该函数改造为符合强保证，如下：
```
void CMessage::Parse(IStream* input)
{
    CMessage temp;
    try
    {
        temp .m_uiMessageLen = input.ReadInteger();//失败会抛出异常
        if(0==temp.m_uiMessageLen||temp .m_uiMessageLen >MAX_MESSAGE_LEN)
        {
            throw invalid_argument("Invalid messageLen in CMessage::Parse ");
        }
        temp .m_pMessage = new char[temp .m_uiMessageLen];//失败抛出异常
        input.Read(temp .m_pMessage, temp .m_uiMessageLen);//失败抛出异常
        //.....
    }
    catch (const exception &exp){
        temp .ResetContent();//把对象的所有字段都设置为无效
        throw exp;
    }
    swap(temp);//成功后执行swap
    return; 
}
```
失败后，对象的状态不受影响；而成功后，执行的swap必须符合无错误保证，否则此函数是无法支持强保证的。

------------------------------------------------
## 14 标准库  
STL标准模板库在不同产品使用程度不同，这里列出一些基本规则和建议，供各团队参考。
### 14.1 规则 
#### 14.1.1 避免使用auto_ptr(C++11已废弃) 
说明：在stl库中的std::auto_ptr具有一个隐式的所有权转移行为，如下代码：
```
auto_ptr<T> p1(new T);
auto_ptr<T> p2 = p1;
```
当执行完第2行语句后，p1已经不再指向第1行中分配的对象，而是变为NULL。正因为如此，auto_ptr不能被置于各种标准容器中。
转移所有权的行为通常不是期望的结果。对于必须转移所有权的场景，也不应该使用隐式转移的方式。这往往需要程序员对使用auto_ptr的代码保持额外的谨慎，否则会出现对空指针的访问。
使用auto_ptr常见的有两种场景，一是作为智能指针传递到产生auto_ptr的函数外部，二是使用auto_ptr作为RAII管理类，在超出auto_ptr的生命周期时自动释放资源。
对于第1种场景，可以使用在C++11标准中是std::shared_ptr来代替。
对于第2种场景，可以使用C++11标准中的std::unique_ptr来代替。其中std::unique_ptr支持显式的所有权转移。
#### 14.1.2 仅将scoped_ptr、shared_ptr和unique_ptr用于管理单个对象 
说明：boost::scoped_ptr、boost::shared_ptr、std::tr1::shared_ptr(在C++11标准中是std::shared_ptr)和std::unique_ptr(C++11标准)都是用于管理单一对象的智能指针。当这些智能指针在销毁所指向的对象时使用的都是delete而不是delete[]，而使用delete删除数组是undefined行为，因此不可使用上述智能指针管理数组。
当需要一个具有RAII特性的数组时，可以使用boost::scoped_array、boost::shared_array、std::vector<std::tr1::shared_ptr>或std::vector<std::unique_ptr> (C++11标准)代替。
shared_ptr是基于引用计数的智能指针，可以安全用于大部分场景中，更新引用计数时需要略微消耗一些性能，一般来说对性能不会有显著的影响。使用shared_ptr的另外一个需要注意的问题是不要产生循环引用，基于引用计数的智能指针当出现循环引用时会造成内存泄漏。当需要循环引用时，其中一个智能指针请使用weak_ptr。
boost::shared_ptr、std::tr1::shared_ptr(std::shared_ptr)的线程安全与stl中常见类型的线程一致，即：
1. 多个线程可以同时读同一个shared_ptr对象；
2. 多个线程可以同时写不同的shared_ptr对象。
注：当多个不同的shared_ptr对象指向同一个底层对象时，同时写这些shared_ptr对象本身是线程安全的，但是需要额外操作保证底层对象的线程安全。 
#### 14.1.3 如果涉及循环引用，使用weak_ptr解开循环  
说明：当使用各种基于引用计数的shared_ptr时，会遇到循环引用的问题，例如：
```
#include <memory>
class TChild;
class TParent
{
public:
    void SetChild(std::shared_ptr<TChild> const& Child)
    {
        Child_ = Child;
    }
private:
    std::shared_ptr<TChild> Child_;
};
class TChild
{
public:
    void SetParent(std::shared_ptr<TParent> const& Parent)
    {
        Parent_ = Parent;
    }
private:
    std::shared_ptr<TParent> Parent_;
};
int main()
{
    std::shared_ptr<TParent> Parent = std::make_shared<TParent>();
    std::shared_ptr<TChild> Child = std::make_shared<TChild>();
    Parent->SetChild(Child);
    Child->SetParent(Parent);
    //到这里Parent和Child产生了循环引用，当Parent、Child超出作用域后将产生内存泄漏。
}
```
为了解决循环引用导致的内存泄漏，需要引入weak_ptr。将代码修改成下面这样：
```
class TChild
{
public:
    void SetParent(std::shared_ptr<TParent> const& Parent)
    {
        Parent_ = Parent;
    }
    void UseParent()
    {
        //使用weak_ptr指向的对象之前通过lock()获得shared_ptr。
        std::shared_ptr<TParent> Parent = Parent_.lock();
    }
private:
    std::weak_ptr<TParent> Parent_;
};
```
注意红色部分以及新增的UseParent()函数，演示了如何使用weak_ptr。另外需要注意的是SetParent()函数中形参依然是shared_ptr，这样将使用了weak_ptr的细节隐藏了起来，从外部看全部是shared_ptr。举例使用的是C++11标准中的std::shared_ptr，但是对于boost::shared_ptr和std::tr1::shared_ptr同样适用。
#### 14.1.4 使用make_shared代替new生成shared_ptr  
说明：在代码中，我们可以使用形如std::shared_ptr<T> A(new T)的方式初始化shared_ptr。但是在涉及到shared_ptr的地方使用new涉及到3个潜在的风险。
一是容易出现下面的代码，访问悬空指针：
```
T* A = new T;
std::shared_ptr<T> B(A);
>xxxxx; //当B超出作用域后：A指向的内存被释放，访问出错
```
二是容易出现下面的代码，引起重复delete：
```
T* A = new T;
std::shared_ptr<T> B(A);
//在许多代码之后再次出现：
std::shared_ptr<T> C(A);
```
当使用一个原生指针初始化一个shared_ptr时，引用计数会被置为1，于是出现了2组独立的引用计数，当这2组引用计数到达0时都会引发销毁对象的操作，于是就会出现重复delete的问题。
三是可能出现内存泄漏的风险，考虑如下代码：
```
int func1();
void func2(std::shared_ptr<T> const& P1, int P2);
int main()
{
    func2(std::shared_ptr<T>(new T), func1());
}
```
在以上调用func2的代码中，根据编译器不同，可能会以以下顺序执行代码：
1. new T
2. func1()
3. std::shared_ptr<T>构造
在这种情况下如果在func1()中抛出了异常，将会造成new T泄漏。所以建议使用new初始化的shared_ptr要放入单独的语句中，即将调用func2的代码修改为：
```
std::shared_ptr<T> temp(new T);
func2(temp, func1());
```
使用以上方法相对略微烦琐，多引入了一个变量。跟shared_ptr配套存在的make_shared可以解决使用new初始化的问题。上述两种情况下的代码可以修改为如下：
```
std::shared_ptr<T> B = std::make_shared<T>();
func2(std::make_shared<T>(), func1());
```
make_shared模板会构造一个指定类型的对象和一个shared_ptr并用该对象初始化shared_ptr，以上操作是一步完成的，不存在中间抛出异常的风险。对于构造时需要参数的类型，将参数加在make_shared模板后面的括号中即可。
#### 14.1.5 对于同一个对象一旦使用shared_ptr，后续就要处处使用shared_ptr  
说明：描述了混用原生指针和shared_ptr容易导致问题：使用悬空指针和重复释放。所以，同一对象的指针要统一用法，要么使用原生指针，要么使用shared_ptr，不要混用。
#### 14.1.6 对于返回自身的shared_ptr指针的对象，要从enable_shared_from_this类派生 
说明：对于需要使用shared_ptr管理的对象，当需要this指针时也需要使用对应的shared_ptr，但是可以看出，如果直接使用shared_ptr<T>(this)构造一个shared_ptr将会导致严重错误。为此，boost和stl都提供了对应的enable_shared_from_this类，该类提供了一个shared_from_this()函数返回this指针对应的shared_ptr。
示例：
```
class TClass : public std::enable_shared_from_this<TClass>
{
public:
    std::shared_ptr<TClass> GetSelf()
    {
        return shared_from_this();
    }
    std::shared_ptr<TClass const> GetSelf() const
    {
        return shared_from_this();
    }
};
```
#### 14.1.7 不要将使用不同版本stl、boost等模板库编译的模块连接在一起 
说明：模板库大量使用了内联函数，不同版本的模板库编译的模块对同一种数据类型的操作都已固化在该模块中。如果不同版本的模板库中同一种数据类型的结构或者内存布局不同，在一个模块中定义的对象被另外一个模块操作时可能会产生严重的错误。因为静态连接的模块常常不会划分出明确的接口，常常会相互访问其它模块中定义的对象。
例外：
有些现存的模块已经无法获得源码，不可能重新使用同一版本的模板库重新编译。在这种情况下，如果模块定义了清晰的接口，且接口中没有传递存在风险的数据类型，可以谨慎地混用，但是一定要进行充足的验证。
#### 14.1.8 不要保存string::c_str()指针  
说明：在C++标准中并未规定string::c_str()指针持久有效，因此特定stl实现完全可以在调用string::c_str()时返回一个临时存储区并很快释放。所以为了保证程序的移植性，一定不要保存string::c_str()的结果，而是在每次需要时直接调用。
示例：
```
//不好的例子：
std::string DemoStr = "demo";
const char* buf = DemoStr.c_str();
//在这里buf指向的位置有可能已经失效。
strncpy（info_buf，buf, INFOBUF_SIZE - 1）;
```
### 14.2 编码建议 
#### 14.2.1 不要将stl、boost等模板库中的数据类型传递到动态链接库或者其它进程中 
说明：跨动态链接库或者其它进程还存在另外一个更复杂的问题，一般来说，内存分配与释放要在同一个模块中，如果将容器或者其它数据类型传递到其它模块中由其它模块进行了内存分配释放操作，将会造成不可预知的问题，通常是程序崩溃或者数据消失等但是也有可能在某些情况下程序完全正常运行，因此定位错误会比较困难。
#### 14.2.2 使用容器时要评估大量插入删除是否会生成大量内存碎片 
说明：不同的操作系统和运行时库分配内存的策略各不相同，由于容器内存多是动态分配而来，对于反复大量插入删除的操作，有可能会造成大量的内存碎片或者内存无法收回。对于长期运行的服务程序，建议在使用容器时要对容器是否会造成内存碎片进行评估和测试，如果存在风险的，可以使用内存池(如boost::pool)来避免这个问题。 
#### 14.2.3 使用string代替char* 
说明：使用string代替char*有很多优势，比如：
1. 不用考虑结尾的’\0’；
2. 可以直接使用+, =, ==等运算符以及其它字符串操作函数；
3. 不需要考虑内存分配操作，避免了显式的new/delete，以及由此导致的错误；
需要注意的是某些stl实现中string是基于写时复制策略的，这会带来2个问题，一是某些版本的写时复制策略没有实现线程安全，在多线程环境下会引起程序崩溃；二是当与动态链接库相互传递基于写时复制策略的string时，由于引用计数在动态链接库被卸载时无法减少可能导致悬挂指针。因此，慎重选择一个可靠的stl实现对于保证程序稳定是很重要的。
例外：
当调用系统或者其它第三方库的API时，针对已经定义好的接口，只能使用char*。但是在调用接口之前都可以使用string，在调用接口时使用string::c_str()获得字符指针。
当在栈上分配字符数组当作缓冲区使用时，可以直接定义字符数组，不要使用string，也没有必要使用类似vector<char>等容器。  
#### 14.2.4 使用stl、boost等知名模板库提供的容器，而不要自己实现容器 
说明：stl、boost等知名模板库已经提供较完善的功能，与其自行设计并维护一个不成熟且不稳定的库，不如掌握和使用标准库，标准库的使用经验在业界已有成熟的经验和使用技巧。  
#### 14.2.5 使用新的标准库头文件  
说明：使用stl的时候，头文件采用<vector>、<cstring>等，而不是<vector.h>、<string.h>。 

------------------------------------------------
## 15 代码编译 
### 15.1 规则 
#### 15.1.1 使用编译器的最高告警级别，理解所有的告警，通过修改代码而不是降低告警级别来消除所有告警  
说明：编译器是你的朋友，如果它发出某个告警，这经常说明你的代码中存在潜在的问题。
#### 15.1.2 在产品软件（项目组）中，要统一编译开关、静态检查选项以及相应告警清除策略  
说明：如果必须禁用某个告警，应尽可能单独局部禁用，并且编写一个清晰的注释，说明为什么屏蔽。
某些语句经编译/静态检查产生告警，但如果你认为它是正确的，那么应通过某种手段去掉告警信息。
#### 15.1.3 本地构建工具（如PC-Lint）的配置应该和持续集成的一致 
说明：两者一致，避免经过本地构建的代码在持续集成上构建失败。 
#### 15.1.4 使用版本控制（配置管理）系统，及时签入通过本地构建的代码，确保签入的代码不会影响构建成功 
说明：及时签入代码降低集成难度。

------------------------------------------------
## 16 程序效率 
### 16.1 C++语言特性的性能分级 
影响软件性能的因素众多，包括软件架构、运行平台(操作系统/编译器/硬件平台)等。很多时候，程序的性能在框架设计完成时就已经确定了。因此当一个程序的性能需要提高时，首先需要做的是用性能检测工具对其运行的时间分布进行一个准确的测量，找出关键路径和真正的瓶颈所在，然后针对瓶颈进行分析和优化，而不是一味盲目地将性能低劣归咎于所采用的语言。事实上，如果框架设计不做修改，即使用C语言或者汇编语言重新改写，也并不能保证提高总体性能。
C++对性能的设计原则是零开销(zero overhead)，其含义是你不用为你不选择的而付费(you don’t pay for what you don’t use)，因此需要了解各种C++语言特性的性能开销。C++语言特性的性能描述采用FREE/CHEAP/EXPENSIVE的分级。
  FREE：性能开销很小，甚至有优化，可以放心使用；
  CHEAP：性能开销有一定程度，多数情况下可以使用，在性能关键地方需要注意；
  EXPENSIVE：性能开销较大，需要按照情况使用，在性能关键地方需要慎重使用。
| C++语言特性 | 性能分级 | 备注 |
| :---| :---- | :---- |
| 封装 | FREE | class和C的struct在使用空间上是相同的，class中的成员函数的时间开销也和C等效代码是一致的。|
| 多态 | FREE | 含有虚函数的class在空间上需要增加虚表指针(4字节)，在虚函数的执行上需要间接寻址的开销。虽然有微量开销，但等同于C等效代码。 |
| 名字空间 | FREE | Namespace会带来符号名字符串长度的增加，但C等效代码也需要增加前缀字符串(比如模块名)。 |
| 隐含内联 | FREE | 没有函数调用的开销，没有指令跳转的顺序执行能让编译器进行更好的优化，但会增加程序大小。 |
| 重载 | FREE | 等效类成员函数的开销。 |
| 构造和析构 | FREE | 等效类成员函数的开销。 |
| 引用 | FREE | 等效或优于指针的使用，引用可以避免指针的间接寻址开销。 |
| 模板 | FREE~EXPENSIVE | 模板具有静态多态的优点，部分逻辑提前到编译阶段以提升性能；但会导致代码膨胀，程序尺寸增大。 |
| RTTI | CHEAP~EXPENSIVE | 执行时间有一定耗时，gcc/VC中dynamic_cast的开销小于10倍函数调用，程序尺寸增大。 |
| 异常 | EXPENSIVE | 异常捕捉很耗时，其包括栈展开等操作，gcc/VC中异常处理开销大于300倍函数调用。 |
| STL | CHEAP~EXPENSIVE | STL提供线性(list)、对数级(map)和常量级(hash_map)不同性能的容器，建议根据应用实际需求选用。 |
### 16.2 C++语言的性能优化指导 
#### 16.2.1 先测量再优化，避免不成熟的优化  
说明：性能涉及到非常多因素，目标不明确的语言层面优化很难显著地改善性能。建议首先测量到性能瓶颈，再对这些性能瓶颈进行针对性的优化。初学者常犯的一个错误，就是编写代码时着迷于过度优化，牺牲了代码的可理解性。
#### 16.2.2 选用合适的算法和数据结构 
说明：代码优化应该从选择合适的算法和数据结构开始。对于元素个数超过1000的数据，其顺序查找算法效率要远低于对数性能的查找算法。std::vector<int>的占用空间约是N*sizeof(int)，而std::list<int>的占用空间约是3N*sizeof(int)。std::map提供了对数级的查找算法，而hash_map则更高，提供了常数级的查找算法，但hash_map需要选择合适的hash算法和桶大小。
#### 16.2.3 在构造函数中用初始化代替赋值 
说明：通过成员初始化列表来进行初始化总是合法的，效率也高于在构造函数体内赋值。
示例：
```
class A 
{
    string s1_;
public:
    A(){s1_ = "Hello,world "; }
};
```
实际上，生成的构造函数代码类似如下：
```
A():s1_(){s1 = "Hello, world"; }
```
成员s1_的缺省构造函数已被隐式调用，构造函数体中的初始化实际上上在调用operator=，而初始化列表只需调用一次s1_的构造函数，相对效率更高。
```
A():s1_("Hello,world "){}
```
#### 16.2.4 当心空的构造函数或析构函数的开销 
说明：空构造函数的开销不一定是0，空构造函数也包括基类构造、类内部成员对象的构造等。如果对象的构造函数或析构函数有相当的开销，建议避免临时对象的使用，并在性能关键路径上考虑避免非临时对象的构造和析构，比如Lazy/Eager/Partial Acquisition设计模式。
```
class Y 
{
    C c;
    D d;
};
class Z : public Y 
{
    E e;
    F f;
public:
    Z() { };
};
Z z; //initialization of c, d, e, f
```
#### 16.2.5 对象参数尽量传递引用(优先)或指针而不是传值 
说明：对于数值类型的int、char等传值既安全又简单；但对于自定义的class、struct、union等对象来说，传引用效率更高：不需要拷贝。class等对象的尺寸一般都大于引用，尤其可能包含隐式的数据成员，虚函数指针等，所以传值的拷贝的代价远远大于引用。不需要构造和析构。如果传值，传入是调用拷贝构造函数，函数退出时还要析构。有利于函数支持派生类。 
示例：
```
void f(T x) //bad
void f(T const* x) //good
void f(T const& x) //good, prefer
```
#### 16.2.6 尽量减少临时对象  
说明：临时对象的产生条件包括：表达式、函数返回、默认参数以及后缀++等等，临时对象都需要创建和删除。对于那些非小型的对象，创建和删除在处理时间和内存方面的代价不菲。采用如下方法可以减少临时对象的产生。
  1用引用或指针类型的参数代替直接传值；
  2用诸如+=代替+  使用匿名的临时对象；
  3避免隐式转换；
示例：
```
Matrix a;
a = b + c; //bad: (b + c) creates a temporary
Matrix a = b;
a += c; //good: no temporary objects created
```
#### 16.2.7 优先采用前置自增/自减  
说明：后置++/--是将对象拷贝到临时对象中，自身++/--，然后再返回临时对象。此过程在非简单数据类型时较为耗时(简单数据类型编译器可以优化)
示例：
```
for (list<X>::iterator it = mylist.begin();it != mylist.end();++it) //good: rather than it++
{
    //...
}
```
#### 16.2.8 简单访问方法尽量采用内联函数 
说明：小函数频繁跳转会带来性能上的损失，内联可以避免性能损失。
```
class X {
private:
    int value_;
    double* array_;
    size_t size_;
public:
    inline int value() { return value_; }
    inline size_t size() { return size_; }
};
```
#### 16.2.9 要审视标准库的性能规格 
说明：std::string是个巨大类，若使用不当(比如大量的+操作)会导致性能迅速下降；std::list<T>::size()在某些实现版本中是线性的，所以在if(myList.size()==0)时可以考虑用if(myList.empty())替换；标准输入输出是性能瓶颈，如果不混用C++和C的标准输入输出库，可以考虑关掉同步：std::ios_base::sync_with_stdio(false)。
#### 16.2.10 用对象池重载动态内存管理器  
说明：系统调用new和delete涉及到系统调用等复杂处理，时间和空间开销都较大，对于DOPRA的内存申请机制也有类似的情况。建议对于特定类的申请和释放，采用自定义的对象池机制管理该对象的申请和释放，而不用操作系统或DOPRA的内存管理机制。对象池的大小需要预先确定或是采用类似std::vector.resize()的方法可以动态增长。
#### 16.2.11 注意大尺寸数组的初始化效率 
说明：我们常这么初始化数组:
```
char szAccount[MAX_ACCOUNT_LEN] = {0};//数组大小16
```
对于字符串确保有结束符即可，故要初始化也应该用“szAccount[0] = 0;”替换之，当然在非关键路径，上述的一行代码完成初始化代码更简洁，也能够被接受。
```
char chTempBuff[MAX_MSG_LEN] = {0};//数组大小为40K
```
而对于如此大的一块内存清0，应该用memset等库函数替代之。编译器不优化情况下，对于{0}的初始化，通常是一个字节逐一赋值为0，而memset在64位平台下很可能是一次8个字节。故当数组大于10个字节时，两者的性能差距在2~8倍，根据数组大小而定。特别是生成或者删除大尺寸的对象数组，每个数组成员的构造函数或析构函数度要被调用一次，花费的时间更多。
#### 16.2.12 避免在函数内部的小块内存分配 
例子 某函数内部，根据消息长度分配内存，然后做相关操作，函数退出前释放内存，如下：
```
char *pMsg = new char[msgLen];
```
其实pMsg的生命周期仅仅在函数内，它所指向的内存其实应该是一个临时变量，如果我们能够预测其最大长度远小于线程栈空间，比如最大几十K，或者只有几十字节，那么就应该声明一个足够大的临时数组，如下：
```
assert(msgLen <= MAX_MSG_LEN);//某些情况下可能需要if检测，而断言检测可能不充分。
char chMsg[MAX_MSG_LEN];//不会有失败和释放的处理，效率也完全不在一个数量级。
```

------------------------------------------------
## 17 并发 
### 17.1 规则 
#### 17.1.1 多线程、进程并行访问共享资源时，一定要加锁保护 
说明：共享资源包括全局变量，静态变量，共享内存，文件等。
建议封装像智能指针一样的对象对锁进行管理，例如封装一个auto_lock，在构造时申请锁，析构中释放锁，保证不会忘记“解锁”。如果锁的作用范围有限，则可以这样：
```
do
{
    auto_lock lock(&lock);
    //....
}while(0);
```
#### 17.1.2 锁的职责单一 
说明：每个锁只锁一个唯一共享资源；这样，才能保证锁应用的单一，也能更好的确保加锁的范围尽量小。
对于共享全局资源，应该根据实际需要，每类或每个资源，有一把锁。这样，这把锁只锁对这个资源访问的代码，通常这样的代码都会是比较简单的资源操作代码，不会是复杂的函数调用等。相反，如果我们对几类或几个资源共用一把锁。这把锁的责任范围就大了，使用复杂，很难理清锁之间的关系(有没有释放锁，或者锁之间的嵌套加锁等)，容易导致死锁问题。
#### 17.1.3 锁范围尽量小，只锁对应资源操作代码 
说明：使用锁时，尽量减少锁的使用范围。我们使用锁，为了方便，会大范围的加锁，如：直接锁几个函数调用。这种使用，一方面会导致多线程执行效率的低下，容易变成串行执行；另一方面，容易出现锁未释放，或者锁的代码中再加锁的场景，最后导致死锁。所以，对锁操作的最好办法，就是只锁简单资源操作代码。对应资源访问完后，马上释放锁。尽量在函数内部靠近资源操作的地方加锁而不是靠近线程、函数外部加锁。
#### 17.1.4 避免嵌套加锁；如果必须加锁，务必保证不同地方的加锁顺序是一样的  
说明：加上一把锁之后，在释放之前，不能再加锁。
典型的锁中加锁的场景：对几个容器的同时遍历，每个容器一把锁，就导致需要加多把锁。这种场景的解决方法：先加一把锁，对一个容器遍历，选择出合乎要求的数据，并保存在临时变量中；再加另一把锁，使用临时变量，再对其他容器遍历。
锁中加锁，必须保证加锁的顺序是一样的，比如先加的锁后解锁， 
```
Lock1
Lock2
Unlock2
Unlock1
```
则其他地方的加锁顺序，必须与这里的顺序一样，避免死锁，不允许出现：
```
lock2
lock1
unlock2
unlock1
```
### 17.2 编码建议
#### 17.2.1 进程间通讯，使用自己保证互斥的数据库系统、共享内存，或socket消息机制；尽量避免使用文件等进程无法管理的资源 
说明：由于文件在不同进程间访问，无法保证互斥。当然，可以在进程间加进程锁，但只受限于我们能加锁的进程，对于第三方进程等无法保证。这样，当多个进程同时对文件进行写操作时，将会导致文件数据破坏，或文件写失败等问题。
当数据库系统本身的访问接口带有互斥机制，当多个进程同时访问时，可以保证数据库数据的完整。
共享内存，只限制于使用共享内存的几个进程，需要我们对这些访问共享内存的进程加锁。但由于共享内存，第三方进程等无法访问，这也能比较好的保护数据，避免文件系统存在的问题。
socket消息机制，由操作系统socket通讯机制保证互斥，在多个进程间，通过消息来保证数据的互斥。
进程的消息都是操作系统转发而来的独立数据，属于进程私有数据，不存在进程间并行访问的问题。
#### 17.2.2 可重入函数尽量只使用局部变量和函数参数，少用全局变量、静态变量 
说明：支持多线程并行访问的函数称之为可重入函数。设计可重入函数时，尽量使用局部变量和函数参数来传递数据，在多线程并行访问时，互相之间不会受影响。相反，如果使用全局变量、静态变量，就需要同步。
示例：
```
int iTotalCnt = 10;
void WriteFile()
{
    for (int i=0; i<iTotalCnt; i++)
    {
        //写个数据到内存；
    }
    iTotalCnt = 0; //写完数据之后，赋值计数为0
 }
 ```
上面的函数，如果是并行访问，将会导致有部分调用WriteFile的线程，不执行for循环；因为iTotalCnt可能被其他线程修改为0。
引申：一些库函数也是非线程安全，调用时可能会出现多线程并发访问问题。 
#### 17.2.3 锁中避免调用函数；如果必须调用函数，务必保证不会造成死锁 
说明：这条规则是对加锁范围尽量小(只锁对应资源操作代码)规则的补充。不能把调用函数也加到加锁范围中。因为被调用函数的内部到底做了什么事情，是如何做的，调用者可能不是很清楚。尤其是当被调用函数内部又加锁的情况，就容易导致两个锁互饿，导致死锁。
示例：
```
Callfunc()
{
    Lock2;
    //….
    Unlock2;
}
Thread_func1()
{
    Lock1;
    Callfunc();
    Unlock1;
}
Thread_func2()
{
    Lock2;
    Lock1;
    //…
    Unlock1;
    Unlock2； 
}
 ```
当上述线程函数Thread_func1()和Thread_func2()并行执行时，就很有可能导致死锁。而且这种死锁情况还是比较难分析。因为我们调用函数，很多时候只关注函数实现的功能，而忽略函数内部的具体实现。其次，锁中调用函数，也会把对资源操作的代码扩大化，不利于并行效率。更主要的是，这种操作，由于加锁的范围变大，引起死锁的可能就增大。 
#### 17.2.4 锁中避免使用跳转语句 
说明：跳转语句包含return、break、continue、goto等。如果锁中有宏调用的代码，要特别注意，分析宏中是否存在隐含的跳转语句。
在函数返回时忘记把锁释放，特别是存在很多分支都可能返回的时候，可能一些分支会忘记释放锁。

------------------------------------------------
## 18 注释 
注释对保证代码可读性至关重要。本章描述了如何注释以及在哪儿注释。当然，注释固然很重要, 但最好的代码应当本身就是文档。有意义的类型名和变量名, 要远胜过要用注释解释的含糊不清的名字。
### 18.1 注释风格
#### 18.1.1 使用 // 或 /* */, 统一就好 
说明：// 或 /* */ 都可以; 但 // 更 常用。要在如何注释及注释风格上确保统一。
### 18.2 文件注释
#### 18.2.1 在每一个文件开头加入版权公告 
说明：文件注释描述了该文件的内容。如果一个文件只声明, 或实现, 或测试了一个对象, 并且这个对象已经在它的声明处进行了详细的注释, 那么就没必要再加上文件注释。除此之外的其他文件都需要文件注释。
包含内容：
1法律公告和作者信息
每个文件都应该包含许可证引用.为项目选择合适的许可证版本。(比如, Apache 2.0, BSD, LGPL, GPL)如果你对原始作者的文件做了重大修改, 请考虑删除原作者信息。
2文件内容
如果一个 .h 文件声明了多个概念, 则文件注释应当对文件的内容做一个大致的说明, 同时说明各概念之间的联系。一个一到两行的文件注释就足够了, 对于每个概念的详细文档应当放在各个概念中, 而不是文件注释中。不要在 .h 和 .cpp 之间复制注释, 这样的注释偏离了注释的实际意义。
### 18.3 类注释 
#### 18.3.1 每个类的定义都要附带一份注释, 描述类的功能和用法, 除非它的功能相当明显 
说明：类注释应当为读者理解如何使用与何时使用类提供足够的信息，同时应当提醒读者在正确使用此类时应当考虑的因素。如果类有任何同步前提，请用文档说明。如果该类的实例可被多线程访问，要特别注意文档说明多线程环境下相关的规则和常量使用。
如果你想用一小段代码演示这个类的基本用法或通常用法，放在类注释里也非常合适。
如果类的声明和定义分开了(例如分别放在了 .h 和 .cpp 文件中)，此时，描述类用法的注释应当和接口定义放在一起，描述类的操作和实现的注释应当和实现放在一起。
### 18.4 函数注释 
#### 18.4.1 函数声明处的注释描述函数功能，定义处的注释描述函数实现 
说明：
函数声明
基本上每个函数声明处前都应当加上注释，描述函数的功能和用途。只有在函数的功能简单而明显时才能省略这些注释(例如，简单的取值和设值函数)。注释使用叙述式 (“Opens the file”) 而非指令式 (“Open the file”)；注释只是为了描述函数，而不是命令函数做什么。通常，注释不会描述函数如何工作。那是函数定义部分的事情。
函数声明处注释的内容：
1函数的输入输出。
2对类成员函数而言：函数调用期间对象是否需要保持引用参数，是否会释放这些参数。
3函数是否分配了必须由调用者释放的空间。
4参数是否可以为空指针。
5是否存在函数使用上的性能隐患。
6如果函数是可重入的, 其同步前提是什么?
举例如下：
```
// Returns an iterator for this table.  It is the client's
// responsibility to delete the iterator when it is done with it,
// and it must not use the iterator once the GargantuanTable object
// on which the iterator was created has been deleted.
//
// The iterator is initially positioned at the beginning of the table.
//
// This method is equivalent to:
//    Iterator* iter = table->NewIterator();
//    iter->Seek("");
//    return iter;
// If you are going to immediately seek to another place in the
// returned iterator, it will be faster to use NewIterator()
// and avoid the extra seek.
Iterator* GetIterator() const;
```
但也要避免罗罗嗦嗦，或者对显而易见的内容进行说明。下面的注释就没有必要加上“否则返回 false”，因为已经暗含其中了：
```
// Returns true if the table cannot hold any more entries.
bool IsTableFull();
```
注释函数重载时，注释的重点应该是函数中被重载的部分，而不是简单的重复被重载的函数的注释。多数情况下，函数重载不需要额外的文档，因此也没有必要加上注释。
注释构造/析构函数时，切记读代码的人知道构造/析构函数的功能，所以“销毁这一对象”这样的注释是没有意义的。你应当注明的是注明构造函数对参数做了什么(例如，是否取得指针所有权)以及析构函数清理了什么。如果都是些无关紧要的内容，直接省掉注释。析构函数前没有注释是很正常的。
函数定义
如果函数的实现过程中用到了很巧妙的方式，那么在函数定义处应当加上解释性的注释。例如，你所使用的编程技巧，实现的大致步骤，或解释如此实现的理由。举个例子，你可以说明为什么函数的前半部分要加锁而后半部分不需要。不要从 .h 文件或其他地方的函数声明处直接复制注释。简要重述函数功能是可以的，但注释重点要放在如何实现上。
### 18.5 变量注释 
#### 18.5.1 通常变量名本身足以很好说明变量用途，某些情况下，也需要额外的注释说明 
说明：
类数据成员
每个类数据成员(也叫实例变量或成员变量)都应该用注释说明用途。如果有非变量的参数(例如特殊值, 数据成员之间的关系, 生命周期等)不能够用类型与变量名明确表达，则应当加上注释。然而，如果变量类型与变量名已经足以描述一个变量，那么就不再需要加上注释。
特别地，如果变量可以接受NULL或-1等警戒值，须加以说明。比如：
```
private:
 // Used to bounds-check table accesses. -1 means
 // that we don't yet know how many entries the table has.
 int num_total_entries_;
```
全局变量
和数据成员一样，所有全局变量也要注释说明含义及用途，以及作为全局变量的原因。比如：
```
// The total number of tests cases that we run through in this regression test.
const int kNumTestCases = 6;
```
### 18.6 实现注释
#### 18.6.1 对于代码中巧妙的，晦涩的，有趣的，重要的地方加以注释 
说明：
代码前注释
巧妙或复杂的代码段前要加注释。比如：
```
// Divide result by two, taking into account that x
// contains the carry from the add.
for (int i = 0; i < result->size(); i++) {
    x = (x << 8) + (*result)[i];
    (*result)[i] = x >> 1;
    x &= 1;
}
```
行注释
比较隐晦的地方要在行尾加入注释。在行尾空两格进行注释。比如：
```
// If we have enough memory, mmap the data portion too.
mmap_budget = max<int64>(0, mmap_budget - index_->length());
if (mmap_budget >= data_size_ && !MmapData(mmap_chunk_bytes, mlock))
    return;  // Error already logged.
```
注意，这里用了两段注释分别描述这段代码的作用，和提示函数返回时错误已经被记入日志。
如果你需要连续进行多行注释，可以使之对齐获得更好的可读性：
```
DoSomething();                  // Comment here so the comments line up.
DoSomethingElseThatIsLonger();  // Two spaces between the code and the comment.
{   // One space before comment when opening a new scope is allowed,
    // thus the comment lines up with the following comments and code.
    DoSomethingElse();  // Two spaces before line comments normally.
}
std::vector<string> list{
                    // Comments in braced lists describe the next element...
                    "First item",
                    // .. and should be aligned appropriately.
"Second item"};
DoSomething(); /* For trailing block comments, one space is fine. */
```
函数参数注释
如果函数参数的意义不明显，考虑用下面的方式进行弥补：
如果参数是一个字面常量，并且这一常量在多处函数调用中被使用，用以推断它们一致，你应当用一个常量名让这一约定变得更明显，并且保证这一约定不会被打破。
考虑更改函数的签名，让某个 bool 类型的参数变为 enum 类型，这样可以让这个参数的值表达其意义。
如果某个函数有多个配置选项，你可以考虑定义一个类或结构体以保存所有的选项，并传入类或结构体的实例。这样的方法有许多优点，例如这样的选项可以在调用处用变量名引用，这样就能清晰地表明其意义。同时也减少了函数参数的数量，使得函数调用更易读也易写。除此之外，以这样的方式，如果你使用其他的选项，就无需对调用点进行更改。
用具名变量代替大段而复杂的嵌套表达式。万不得已时，才考虑在调用点用注释阐明参数的意义。
不允许的行为
不要描述显而易见的现象，永远不要用自然语言翻译代码作为注释，除非即使对深入理解C++的读者来说代码的行为都是不明显的。要假设读代码的人C++水平比你高，即便他/她可能不知道你的用意：
你所提供的注释应当解释代码为什么要这么做和代码的目的，或者最好是让代码自文档化。
比较这样的注释：
```
// Find the element in the vector.  <-- 差: 这太明显了!
auto iter = std::find(v.begin(), v.end(), element);
if (iter != v.end()) {
    Process(element);
}
```
和这样的注释：
```
// Process "element" unless it was already processed.
auto iter = std::find(v.begin(), v.end(), element);
if (iter != v.end()) {
    Process(element);
}
```
自文档化的代码根本就不需要注释。上面例子中的注释对下面的代码来说就是毫无必要的：
```
if (!IsAlreadyProcessed(element)) {
    Process(element);
}
```
### 18.7 标点, 拼写和语法
#### 18.7.1 注意标点，拼写和语法；写的好的注释比差的要易读的多 
说明：注释的通常写法是包含正确大小写和结尾句号的完整叙述性语句。大多数情况下，完整的句子比句子片段可读性更高。短一点的注释，比如代码行尾注释，可以随意点，但依然要注意风格的一致。
虽然被别人指出该用分号时却用了逗号多少有些尴尬，但清晰易读的代码还是很重要的。正确的标点，拼写和语法对此会有很大帮助。
### 18.8 TODO 注释 
#### 18.8.1 对那些临时的，短期的解决方案，或已经够好但仍不完美的代码使用TODO注释 
说明：TODO注释要使用全大写的字符串TODO，在随后的圆括号里写上你的名字，邮件地址，bug ID，或其它身份标识和与这一TODO相关的 issue。主要目的是让添加注释的人(也是可以请求提供更多细节的人)可根据规范的 TODO格式进行查找。添加TODO注释并不意味着你要自己来修正，因此当你加上带有姓名的TODO时，一般都是写上自己的名字。
```
// TODO(kl@gmail.com): Use a "*" here for concatenation operator
// TODO(Zeke) change this to use relations.
// TODO(bug 12345): remove the "Last visitors" feature
```
如果加TODO是为了在“将来某一天做某事”，可以附上一个非常明确的时间“Fix by November 2005”)，或者一个明确的事项(“Remove this code when all clients can handle XML responses.”)。
### 18.9 弃用注释 
#### 18.9.1 通过弃用注释（DEPRECATED comments）以标记某接口点已弃用 
说明：您可以写上包含全大写的DEPRECATED的注释，以标记某接口为弃用状态。注释可以放在接口声明前，或者同一行。在DEPRECATED一词后，在括号中留下您的名字，邮箱地址以及其他身份标识。弃用注释应当包涵简短而清晰的指引，以帮助其他人修复其调用点。在C++中，你可以将一个弃用函数改造成一个内联函数，这一函数将调用新的接口。仅仅标记接口为DEPRECATED并不会让大家不约而同地弃用，您还得亲自主动修正调用点（callsites），或是找个帮手。
修正好的代码应该不会再涉及弃用接口点了，着实改用新接口点。如果您不知从何下手，可以找标记弃用注释的当事人一起商量。

------------------------------------------------
## 19 格式 
每个人都可能有自己的代码风格和格式，但如果一个项目中的所有人都遵循同一风格的话，这个项目就能更顺利地进行。每个人未必能同意下述的每一处格式规则，而且其中的不少规则需要一定时间的适应，但整个项目服从统一的编程风格是很重要的，只有这样才能让所有人轻松地阅读和理解代码。
### 19.1 行长度 
#### 19.1.1 每一行代码字符数不超过80
说明：此规则是有争议的，但很多已有代码都遵照这一规则，因此我们感觉一致性更重要。如果无法在不伤害易读性的条件下进行断行，那么注释行可以超过80个字符，这样可以方便复制粘贴。例如，带有命令示例或URL的行可以超过80个字符。包含长路径的#include语句可以超出80列。
头文件保护可以无视该原则。
### 19.2 非ASCII字符 
#### 19.2.1 尽量不使用非ASCII字符，使用时必须使用UTF-8编码 
说明：即使是英文，也不应将用户界面的文本硬编码到源代码中，因此非ASCII字符应当很少被用到。特殊情况下可以适当包含此类字符。例如，代码分析外部数据文件时，可以适当硬编码数据文件中作为分隔符的非ASCII字符串; 更常见的是(不需要本地化的)单元测试代码可能包含非ASCII字符串。此类情况下，应使用UTF-8编码，因为很多工具都可以理解和处理UTF-8编码。
十六进制编码也可以，能增强可读性的情况下尤其鼓励——比如 "\xEF\xBB\xBF"，或者更简洁地写作u8"\uFEFF"，在Unicode中是零宽度、无间断的间隔符号，如果不用十六进制直接放在UTF-8格式的源文件中，是看不到的。
使用u8前缀把带uXXXX转义序列的字符串字面值编码成UTF-8。不要用在本身就带UTF-8字符的字符串字面值上，因为如果编译器不把源代码识别成 UTF-8，输出就会出错。
别用C++1的char16_t和 char32_t，它们和UTF-8文本没有关系，wchar_t同理，除非你写的代码要调Windows API，后者广泛使用了wchar_t。
### 19.3 空格还是制表位 
#### 19.3.1 只使用空格, 每次缩进4个空格 
说明：我们使用空格缩进。不要在代码中使用制表符，你应该设置编辑器将制表符转为空格。
### 19.4 函数声明与定义 
#### 19.4.1 返回类型和函数名在同一行, 参数也尽量放在同一行, 如果放不下就对形参分行, 分行方式与函数调用一致 
说明：函数看上去像这样：
```
ReturnType ClassName::FunctionName(Type par_name1, Type par_name2) {
    DoSomething();
    ...
}
```
如果同一行文本太多，放不下所有参数：
```
ReturnType ClassName::ReallyLongFunctionName(Type par_name1, Type par_name2,
                                             Type par_name3) {
    DoSomething();
    ...
}
```
甚至连第一个参数都放不下：
```
ReturnType LongClassName::ReallyReallyReallyLongFunctionName(
    Type par_name1,  // 4 space indent
    Type par_name2,
    Type par_name3) {
    DoSomething();  // 2 space indent
  ...
}
```
注意以下几点：
1使用好的参数名。
2只有在参数未被使用或者其用途非常明显时，才能省略参数名。
3如果返回类型和函数名在一行放不下，分行。
4如果返回类型与函数声明或定义分行了，不要缩进。
5左圆括号总是和函数名在同一行。
6函数名和左圆括号间永远没有空格。
7圆括号与参数间没有空格。
8左大括号总在最后一个参数同一行的末尾处，不另起新行。
9右大括号总是单独位于函数最后一行，或者与左大括号同一行。
10右圆括号和左大括号间总是有一个空格。
11所有形参应尽可能对齐。
12缺省缩进为4个空格。
13换行后的参数保持4个空格的缩进。
未被使用的参数，或者根据上下文很容易看出其用途的参数，可以省略参数名：
```
class Foo {
public:
    Foo(Foo&&);
    Foo(const Foo&);
    Foo& operator=(Foo&&);
    Foo& operator=(const Foo&);
};
```
未被使用的参数如果其用途不明显的话，在函数定义处将参数名注释起来：
```
class Shape {
public:
    virtual void Rotate(double radians) = 0;
};

class Circle : public Shape {
public:
    void Rotate(double radians) override;
};
void Circle::Rotate(double /*radians*/) {}
// 差 - 如果将来有人要实现，很难猜出变量的作用。
void Circle::Rotate(double) {}
```
属性，和展开为属性的宏，写在函数声明或定义的最前面，即返回类型之前：
```
MUST_USE_RESULT bool IsOK();
```
### 19.5 Lambda表达式 
#### 19.5.1 Lambda表达式对形参和函数体的格式化和其他函数一致；捕获列表同理，表项用逗号隔开 
说明：若用引用捕获，在变量名和 & 之间不留空格。
```
int x = 0;
auto add_to_x = [&x](int n) { x += n; };
```
短 lambda 就写得和内联函数一样。
```
std::set<int> blacklist = {7, 8, 9};
std::vector<int> digits = {3, 9, 1, 8, 4, 7, 1};
digits.erase(std::remove_if(digits.begin(), digits.end(), [&blacklist](int i) {
               return blacklist.find(i) != blacklist.end();
             }),
             digits.end());
```
### 19.6 函数调用
总述：要么一行写完函数调用，要么在圆括号里对参数分行，要么参数另起一行且缩进四格。如果没有其它顾虑的话，尽可能精简行数，比如把多个参数适当地放在同一行里。
说明：函数调用遵循如下形式：
```
bool retval = DoSomething(argument1, argument2, argument3);
```
如果同一行放不下，可断为多行，后面每一行都和第一个实参对齐，左圆括号后和右圆括号前不要留空格：
```
bool retval = DoSomething(averyveryveryverylongargument1,
                          argument2, argument3);
```
参数也可以放在次行, 缩进四格：
```
if (...) {
    ...
    ...
    if (...) {
      DoSomething(
          argument1, argument2,  // 4 空格缩进
          argument3, argument4);
    }
}
```
把多个参数放在同一行以减少函数调用所需的行数，除非影响到可读性。有人认为把每个参数都独立成行，不仅更好读，而且方便编辑参数。不过，比起所谓的参数编辑，我们更看重可读性，且后者比较好办：
如果一些参数本身就是略复杂的表达式，且降低了可读性，那么可以直接创建临时变量描述该表达式，并传递给函数：
```
int my_heuristic = scores[x] * y + bases[x];
bool retval = DoSomething(my_heuristic, x, y, z);
```
或者放着不管，补充上注释：
```
bool retval = DoSomething(scores[x] * y + bases[x],  // Score heuristic.
                          x, y, z);
```
如果某参数独立成行，对可读性更有帮助的话，那也可以如此做。参数的格式处理应当以可读性而非其他作为最重要的原则。
此外，如果一系列参数本身就有一定的结构，可以酌情地按其结构来决定参数格式：
```
// 通过3x3矩阵转换widget。
my_widget.Transform(x1, x2, x3,
                    y1, y2, y3,
                    z1, z2, z3);
```
### 19.7 条件语句 
#### 19.7.1 倾向于不在圆括号内使用空格，关键字if和else另起一行 
说明：对基本条件语句有两种可以接受的格式。一种在圆括号和条件之间有空格，另一种没有。
最常见的是没有空格的格式。哪一种都可以，最重要的是保持一致。如果你是在修改一个文件，参考当前已有格式。如果是写新的代码，参考目录下或项目中其它文件。还在犹豫的话，就不要加空格了。
```
if (condition) {  // 圆括号里没有空格
    ...  // 4空格缩进
} else if (...) {  // else与if的右括号同一行
    ...
} else {
    ...
}
```
如果你更喜欢在圆括号内部加空格：
```
if ( condition ) {  // 圆括号与空格紧邻 - 不常见
    ...  //4空格缩进
} else {  // else与if的右括号同一行
    ...
}
```
注意所有情况下if和左圆括号间都有个空格。右圆括号和左大括号之间也要有个空格：
```
if(condition)     // 差 - IF 后面没空格
if (condition){   // 差 - { 前面没空格
if(condition){    // 变本加厉地差
if (condition) {  // 好 - IF 和 { 都与空格紧邻
```
如果能增强可读性，简短的条件语句允许写在同一行。只有当语句简单并且没有使用else子句时使用：
```
if (x == kFoo) return new Foo();
if (x == kBar) return new Bar();
```
如果语句有else分支则不允许：
```
// 不允许 - 当有ELSE分支时IF块却写在同一行
if (x) DoThis();
else DoThat();
```
通常，单行语句不需要使用大括号，如果你喜欢用也没问题；复杂的条件或循环语句用大括号可读性会更好。也有一些项目要求if必须总是使用大括号：
```
if (condition)
    DoSomething();  //4空格缩进
if (condition) {
    DoSomething();  //4空格缩进
}
```
但如果语句中某个 if-else分支使用了大括号的话，其它分支也必须使用：
```
// 不可以这样子- IF有大括号ELSE却没有
if (condition) {
    foo;
} else
    bar;
// 不可以这样子- ELSE有大括号IF却没有
if (condition)
    foo;
else {
    bar;
}
// 只要其中一个分支用了大括号，两个分支都要用上大括号
if (condition) {
    foo;
} else {
    bar;
}
```
### 19.8 循环和开关选择语句 
#### 19.8.1 switch语句可以使用大括号分段，以表明cases之间不是连在一起的。在单语句循环里，括号可用可不用，空循环体应使用{} 或continue
说明：switch 语句中的 case 块可以使用大括号也可以不用，取决于你的个人喜好。如果用的话，要按照下文所述的方法。
如果有不满足case条件的枚举值，switch应该总是包含一个default匹配 (如果有输入值没有case去处理，编译器将给出warning)。如果default应该永远执行不到，简单的加条assert：
```
switch (var) {
    case 0: {  
      ...      
      break;
    }
    case 1: {
      ...
      break;
    }
    default: {
      assert(false);
    }
}
```
在单语句循环里，括号可用可不用：
```
for (int i = 0; i < kSomeNumber; ++i)
    printf("I love you\n");
for (int i = 0; i < kSomeNumber; ++i) {
    printf("I take it back\n");
}
```
空循环体应使用{}或continue，而不是一个简单的分号。
```
while (condition) {
    // 反复循环直到条件失效
}
for (int i = 0; i < kSomeNumber; ++i) {}  // 可-空循环体
while (condition) continue;  // 可 - contunue表明没有逻辑
while (condition);  // 差-看起来仅仅只是while/loop的部分之一
```
### 19.9 指针和引用表达式 
#### 19.9.1 句点或箭头前后不要有空格，指针/地址操作符(*, &)之后不能有空格 
说明：下面是指针和引用表达式的正确使用范例：
```
x = *p;
p = &x;
x = r.y;
x = r->y;
```
注意：
在访问成员时，句点或箭头前后没有空格。
指针操作符*或&后没有空格。
在声明指针变量或参数时，星号与类型或变量名紧挨都可以：
```
// 好，空格前置
char *c;
const string &str;

// 好，空格后置
char* c;
const string& str;
int x, *y;  // 不允许 - 在多重声明中不能使用 & 或 *
char * c;  // 差 - * 两边都有空格
const string & str;  // 差 - & 两边都有空格
```
在单个文件内要保持风格一致，所以，如果是修改现有文件，要遵照该文件的风格。
### 19.10 布尔表达式 
#### 19.10.1 如果一个布尔表达式超过标准行宽，断行方式要统一一下 
说明：下例中，逻辑与 (&&) 操作符总位于行尾：
```
if (this_one_thing > this_other_thing &&
    a_third_thing == a_fourth_thing &&
    yet_another && last_one) {
  ...
}
```
注意，上例的逻辑与 (&&) 操作符均位于行尾。虽然把所有操作符放在开头也可以。可以考虑额外插入圆括号，合理使用的话对增强可读性是很有帮助的。此外，直接用符号形式的操作符，比如 && 和 ~，不要用词语形式的and和 compl。
### 19.11 函数返回值 
#### 19.11.1 不要在return表达式里加上非必须的圆括号 
说明：只有在写 x = expr 要加上括号的时候才在 return expr; 里使用括号
```
return result;                  // 返回值很简单，没有圆括号
// 可以用圆括号把复杂表达式圈起来，改善可读性
return (some_long_condition &&
      another_condition);
return (value);                // 毕竟您从来不会写 var = (value);
return(result);                // return 可不是函数！
```
### 19.12 变量及数组初始化 
#### 19.12.1 用 =, () 和 {} 均可 
您可以用 =, () 和 {}, 以下的例子都是正确的：
```
int x = 3;
int x(3);
int x{3};
string name("Some Name");
string name = "Some Name";
string name{"Some Name"};
```
请务必小心列表初始化 {...} 用 std::initializer_list 构造函数初始化出的类型。非空列表初始化就会优先调用 
std::initializer_list, 不过空列表初始化除外，后者原则上会调用默认构造函数。为了强制禁用 std::initializer_list 构造函数，请改用括号。
```
vector<int> v(100, 1);  // 内容为 100 个 1 的向量
vector<int> v{100, 1};  // 内容为 100 和 1 的向量
```
此外, 列表初始化不允许整型类型的四舍五入，这可以用来避免一些类型上的编程失误。
```
int pi(3.14);  // 好 - pi == 3
int pi{3.14};  // 编译错误：缩窄转换
```
### 19.13 预处理指令 
#### 19.13.1 预处理指令不要缩进，从行首开始 
即使预处理指令位于缩进代码块中，指令也应从行首开始。
```
// 好 - 指令从行首开始
    if (lopsided_score) {
#if DISASTER_PENDING      // 正确 - 从行首开始
        DropEverything();
# if NOTIFY               // 非必要 - # 后跟空格
        NotifyClient();
# endif
#endif
        BackToNormal();
    }
// 差 - 指令缩进
    if (lopsided_score) {
#if DISASTER_PENDING  // 差 - "#if" 应该放在行开头
        DropEverything();
#endif                // 差 - "#endif" 不要缩进
        BackToNormal();
    }
```
### 19.14 类格式
#### 19.14.1 访问控制块的声明依次序是 public:，protected:，private: 
说明：类声明 (下面的代码中缺少注释, 参考 类注释) 的基本格式如下：
```
class MyClass : public OtherClass {
public:      
    MyClass();  // 标准的4空格缩进
    explicit MyClass(int var);
    ~MyClass() {}

    void SomeFunction();
    void SomeFunctionThatDoesNothing() {
  }

    void set_some_var(int var) { some_var_ = var; }
    int some_var() const { return some_var_; }

private:
    bool SomeInternalFunction();

    int some_var_;
    int some_other_var_;
};
```
注意事项:
1所有基类名应在80列限制下尽量与子类名放在同一行。
2除第一个关键词(一般是public)外，其他关键词前要空一行，如果类比较小的话也可以不空。
3这些关键词后不要保留空行。
4 public 放在最前面，然后是protected，最后是private。
### 19.15 构造函数初始值列表 
#### 19.15.1 构造函数初始化列表放在同一行或按四格缩进并排多行 
下面两种初始值列表方式都可以接受：
```
// 如果所有变量能放在同一行：
MyClass::MyClass(int var) : some_var_(var) {
    DoSomething();
}
// 如果不能放在同一行
// 必须置于冒号后，并缩进 4 个空格
MyClass::MyClass(int var)
    : some_var_(var), some_other_var_(var + 1) {
    DoSomething();
}
// 如果初始化列表需要置于多行，将每一个成员放在单独的一行
// 并逐行对齐
MyClass::MyClass(int var)
    : some_var_(var),             // 4 space indent
     some_other_var_(var + 1) {  // lined up
    DoSomething();
}
// 右大括号 } 可以和左大括号 { 放在同一行
// 如果这样做合适的话
MyClass::MyClass(int var)
    : some_var_(var) {}
```
### 19.16 命名空间格式化 
#### 19.16.1 命名空间内容不缩进 
说明：命名空间不要增加额外的缩进层次，例如：
```
namespace {

void foo() {  // 正确。命名空间内没有额外的缩进
  ...
}

}  // namespace
```
不要在命名空间内缩进：
```
namespace {

  // 错, 缩进多余了
  void foo() {
    ...
  }

}  // namespace
```
声明嵌套命名空间时，每个命名空间都独立成行
```
namespace foo {
namespace bar {
```  
### 19.17 水平留白 
### 19.17.1 水平留白的使用根据在代码中的位置决定，永远不要在行尾添加没意义的留白 
通用
```  
void f(bool b) {  // 左大括号前总是有空格
  ...
int i = 0;  // 分号前不加空格
// 列表初始化中大括号内的空格是可选的
// 如果加了空格，那么两边都要加上
int x[] = { 0 };
int x[] = {0};

// 继承与初始化列表中的冒号前后恒有空格
class Foo : public Bar {
public:
    // 对于单行函数的实现，在大括号内加上空格
    // 然后是函数实现
    Foo(int b) : Bar(), baz_(b) {}  // 大括号里面是空的话，不加空格
    void Reset() { baz_ = 0; }  // 用括号把大括号与实现分开
    ...
```  
添加冗余的留白会给其他人编辑时造成额外负担。因此，行尾不要留空格。如果确定一行代码已经修改完毕，将多余的空格去掉；或者在专门清理空格时去掉（尤其是在没有其他人在处理这件事的时候)。(Yang.Y 注：现在大部分代码编辑器稍加设置后，都支持自动删除行首/行尾空格，如果不支持，考虑换一款编辑器或 IDE)
循环和条件语句
```  
if (b) {          // if 条件语句和循环语句关键字后均有空格
} else {          // else 前后有空格
}
while (test) {}   // 圆括号内部不紧邻空格
switch (i) {
for (int i = 0; i < 5; ++i) {
switch ( i ) {    // 循环和条件语句的圆括号里可以与空格紧邻
if ( test ) {     // 圆括号, 但这很少见. 总之要一致
for ( int i = 0; i < 5; ++i ) {
for ( ; i < 5 ; ++i) {  // 循环里内 ; 后恒有空格, ;  前可以加个空格
switch (i) {
    case 1:         // switch case 的冒号前无空格
      ...
    case 2: break;  // 如果冒号有代码，加个空格
```  
操作符
```  
// 赋值运算符前后总是有空格
x = 0;

// 其它二元操作符也前后恒有空格，不过对于表达式的子式可以不加空格
// 圆括号内部没有紧邻空格
v = w * x + y / z;
v = w*x + y/z;
v = w * (x + z);

// 在参数和一元操作符之间不加空格
x = -5;
++x;
if (x && !y)
    ...
```  
模板和转换
```  
// 尖括号(< and >) 不与空格紧邻，< 前没有空格, > 和 ( 之间也没有
vector<string> x;
y = static_cast<char*>(x);

// 在类型与指针操作符之间留空格也可以，但要保持一致
vector<char *> x;
```  
### 19.18 垂直留白 
#### 19.18.1 垂直留白越少越好 
说明：这不仅仅是规则而是原则问题了：不在万不得已，不要使用空行。尤其是：两个函数定义之间的空行不要超过2行，函数体首尾不要留空行，函数体中也不要随意添加空行。
基本原则是：同一屏可以显示的代码越多，越容易理解程序的控制流。当然，过于密集的代码块和过于疏松的代码块同样难看，这取决于你的判断。但通常是垂直留白越少越好。
下面的规则可以让加入的空行更有效：
函数体内开头或结尾的空行可读性微乎其微。
在多重 if-else 块里加空行或许有点可读性。

------------------------------------------------
## 20 可测性 
### 20.1 原则 
#### 20.1.1 模块划分清晰，接口明确，耦合性小，有明确输入和输出，否则单元测试实施困难  
说明：单元测试实施依赖于：
  1模块间的接口定义清楚、完整、稳定；
  2模块功能的有明确的验收条件（包括：预置条件、输入和预期结果）；
  3模块内部的关键状态和关键数据可以查询，可以修改；
  4模块原子功能的入口唯一；
  5模块原子功能的出口唯一；
  6依赖集中处理：和模块相关的全局变量尽量的少，或者采用某种封装形式。
### 20.2 规则
#### 20.2.1 在同一项目组或产品组内，要有一套统一的为集成测试与系统联调准备的调测开关及相应打印函数，并且要有详细的说明 
说明：本规则是针对项目组或产品组的。代码至始至终只有一份代码，不存在开发版本和测试版本的说法。测试与最终发行的版本是通过编译开关的不同来实现的。并且编译开关要规范统一。统一使用编译开关来实现测试版本与发行版本的区别，一般不允许再定义其它新的编译开关。
#### 20.2.2 在同一项目组或产品组内，调测打印的日志要有统一的规定 
说明：统一的调测日志记录便于集成测试，具体包括：
  1统一的日志分类以及日志级别；
  2通过命令行、网管等方式可以配置和改变日志输出的内容和格式；
  3在关键分支要记录日志，日志建议不要记录在原子函数中，否则难以定位；
  4调试日志记录的内容需要包括文件名/模块名、代码行号、函数名、被调用函数名、错误码、错误发生的环境等。
#### 20.2.3 使用断言记录内部假设  
说明：断言是对某种内部模块的假设条件进行检查，如果假设不成立，说明存在编程、设计错误。断言可以对在系统中隐藏很深，用其它手段极难发现的问题进行定位，从而缩短软件问题定位时间，提高系统的可测性。
#### 20.2.4 不能用断言来检查运行时错误 
说明：断言是用来处理内部编程或设计是否符合假设；不能处理对于可能会发生的且必须处理的情况要写防错程序，而不是断言。如某模块收到其它模块或链路上的消息后，要对消息的合理性进行检查，此过程为正常的错误检查，不能用断言来实现。
断言的使用是有条件的。断言只能用于程序内部逻辑的条件判断，而不能用于对外部输入数据的判断,因为在网上实际运行时，是完全有可能出现外部输入非法数据的情况。

------------------------------------------------
## 21 安全性 
代码的安全漏洞大都是由代码缺陷导致，但不是所有代码缺陷都有安全风险。理解安全漏洞产生的原理和如何进行安全编码是减少软件安全问题最直接有效的办法。
### 21.1 原则 
#### 21.1.1 对用户输入进行检查 
说明：不能假定用户输入都是合法的，因为难以保证不存在恶意用户，即使是合法用户也可能由于误用误操作而产生非法输入。用户输入通常需要经过检验以保证安全，特别是以下场景：
  1用户输入作为循环条件
  2用户输入作为数组下标
  3用户输入作为内存分配的尺寸参数
  4用户输入作为格式化字符串
  5用户输入作为业务数据（如作为命令执行参数、拼装sql语句、以特定格式持久化）
这些情况下如果不对用户数据做合法性验证，很可能导致DOS、内存越界、格式化字符串漏洞、命令注入、SQL注入、缓冲区溢出、数据破坏等问题。
可采取以下措施对用户输入检查：
  1用户输入作为数值的，做数值范围检查
  2用户输入是字符串的，检查字符串长度
  3用户输入作为格式化字符串的，检查关键字“%”  用户输入作为业务数据，对关键字进行检查、转义
### 21.2 规则
#### 21.2.1 确保所有字符串是以NULL结束 
说明：C语言中‟\0‟作为字符串的结束符，即NULL结束符。标准字符串处理函数（如strcpy()、strlen()）依赖NULL结束符来确定字符串的长度。没有正确使用NULL结束字符串会导致缓冲区溢出和其它未定义的行为。
为了避免缓冲区溢出，常常会用相对安全的限制字符数量的字符串操作函数代替一些危险函数。如：
  用strncpy()代替strcpy()
  用strncat()代替strcat()
  用snprintf()代替sprintf()
  用fgets()代替gets()
这些函数会截断超出指定限制的字符串，但是要注意它们并不能保证目标字符串总是以NULL结尾。如果源字符串的前n个字符中不存在NULL字符，目标字符串就不是以NULL结尾。
示例：
```
char a[16];
strncpy(a, "0123456789abcdef", sizeof(a));
```
上述代码存在安全风险：在调用strncpy()后，字符数组a中的字符串是没有NULL结束符的，也没有空间存放NULL结束符。
正确写法：截断字符串，保证字符串以NULL结束。
```
char a[16];
strncpy(a, "0123456789abcdef", sizeof(a) - 1 );
a[sizeof(a) - 1] = '\0';
```
#### 21.2.2 不要将边界不明确的字符串写到固定长度的数组中  
说明：边界不明确的字符串，长度可能大于目标数组长度，直接拷贝到固定长度的数组中容易导致缓冲区溢出。
示例：
```
char buff[256];
char *editor = getenv("EDITOR");
if (editor != NULL) 
{
    strcpy(buff, editor);
}
```
上述代码读取环境变量"EDITOR"的值，如果成功则拷贝到缓冲区buff中。而从环境变量获取到的字符串长度是不确定的，把它们拷贝到固定长度的数组中很可能导致缓冲区溢出。
正确写法：计算字符串的实际长度，再分配指定长度的内存。
#### 21.2.3 避免整数溢出 
说明：当一个整数被增加超过其最大值时会发生整数上溢，被减小小于其最小值时会发生整数下溢。
带符号和无符号的数都有可能发生溢出。
示例1：有符号和无符号整数的上溢和下溢
```
int i;
unsigned int j;
i = INT_MAX; // 2,147,483,647
i++;
printf("i = %d\n", i); // i=-2,147,483,648
j = UINT_MAX; // 4,294,967,295;
j++;
printf("j = %u\n", j); // j = 0
i = INT_MIN; // -2,147,483,648;
i--;
printf("i = %d\n", i); // i = 2,147,483,647
j = 0;
j--;
printf("j = %u\n", j); // j = 4,294,967,295
```
示例2：整数下溢导致报文长度异常
```
/* 报文长度减去FSM头的长度*/
unsigned int length;
length -= FSM_HDRLEN ;
```
处理过短报文时，length的长度可能小于FSM_HDRLEN，减法的结果小于。由于length是无符号数，结果返回了一个很大的数。
正确写法：增加长度检查
```
if (length < FSM_HDRLEN ) 
{
    return VOS_ERROR;
} 
length -= FSM_HDRLEN ;
```
#### 21.2.4 避免符号错误 
说明：有时从带符号整型转换到无符号整型会发生符号错误，符号错误并不丢失数据，但数据失去了原来的含义。
带符号整型转换到无符号整型，最高位（high-order bit）会丧失其作为符号位的功能。如果该带符号整数的值非负，那么转换后值不变；如果该带符号整数的值为负，那么转换后的结果通常是一个非常大的正数。
示例：符号错误绕过长度检查
```
#define BUF_SIZE 10
int main(int argc,char* argv[])
{
    int length;
    char buf[BUF_SIZE];
    if (argc != 3)
    {
        return -1;
    }
    length = atoi(argv[1]); //如果atoi返回的长度为负数
    if (length < BUF_SIZE) // len为负数，长度检查无效 
    {
        memcpy(buf, argv[2], length); /* 带符号的len被转换为size_t类型的无符号整数，负值被解释为一个极大的正整数。memcpy()调用时引发buf缓冲区溢出 */ 
        printf("Data copied\n");
    }
    else
    {
        printf("Too many data\n");
    }
}
```
正确写法1：将len声明为无符号整型
```
#define BUF_SIZE 10
int main(int argc, char* argv[])
{
    unsigned int length;
    char buf[BUF_SIZE];
    if (argc != 3)
    {
        return -1;
    }
    length = atoi(argv[1]);
    if (length < BUF_SIZE)
    {
        memcpy(buf, argv[2], length);
        printf("Data copied\n");
    }
    else
    {
        printf("Too much data\n");
    }
    return 0;
}
```
正确写法2：增加对len的更有效的范围校验
```
#define BUF_SIZE 10
int main(int argc, char* argv[])
{
    int length;
    char buf[BUF_SIZE];
    if (argc != 3)
    {
        return -1;
    }
    length = atoi(argv[1]);
    if ((length > 0) && (length < BUF_SIZE))
    {
        memcpy(buf, argv[2], length);
        printf("Data copied\n");
    }
    else
    {
        printf("Too much data\n");
    }
    return 0;
}
```
#### 21.2.5 避免截断错误
说明：将一个较大整型转换为较小整型，并且该数的原值超出较小类型的表示范围，就会发生截断错误，原值的低位被保留而高位被丢弃。截断错误会引起数据丢失。
使用截断后的变量进行内存操作，很可能会引发问题。
#### 21.2.6 避免使用strlen()计算二进制数据的长度  
说明：strlen()函数用于计算字符串的长度，它返回字符串中第一个NULL结束符之前的字符的数量。
因此用strlen()处理文件I/O函数读取的内容时要小心，因为这些内容可能是二进制也可能是文本。
示例：
```
char buf[BUF_SIZE + 1];
if (fgets(buf, sizeof(buf), fp) == NULL) 
{
    /* handle error */
}
buf[strlen(buf) - 1] = '\0';
``` 
上述代码试图从一个输入行中删除行尾的换行符（\n）。如果buf的第一个字符是NULL，strlen(buf)返回0，这时对buf进行数组下标为[-1]的访问操作将会越界。
正确做法：在不能确定从文件读取到的数据的类型时，不要使用依赖NULL结束符的字符串操作函数。
```
char buf[BUF_SIZE + 1];
char *p;
if (fgets(buf, sizeof(buf), fp)) 
{
    p = strchr(buf, '\n');
    if (p) 
    {
        *p = '\0';
    } 
}
else
{
     /* handle error condition */
}
```

------------------------------------------------
## 22 可移植性 
本章讨论C++可移植性问题主要关注：32位移植到64位，不同CPU架构之间的移植。
移植中一些关键问题如下：
1. 指针截断
2. 数据类型字节对齐
3. 对内存地址的错误假设
4. 对复合数据类型成员地址的错误假设
5. 大小端，网络字节序问题
### 22.1 编码建议 
#### 22.1.1 不直接使用C++的基本数据类型，不要假定其存储尺寸长度  
说明：C++标准没有明确基本数据类型的大小与存储格式，这些基本类型包括：short，int, long, long long, float double等。这些基本数据类型在不同的编译器中，实现有所不同，如：
long类型在32位编译模式下为4字节长度，在64位编译模式下为8字节长度。
所以建议不要直接使用基本数据类型。推荐如下两种使用方式：
1、重定义基本数据类型
```
typedef int32_t int;
typedef int64_t long long;
```
使用重定义后的基本类型好处是：如果程序需要移植，可以大大减少移植的工作量。
2、使用C99标准中定义的标准类型
```
int64_t my_value = 0x123456789LL;
uint64_t my_mask = 3ULL << 48;
```
使用这些标准类型长度的好处是，它们规定了固定的长度，这个长度不会随编译器变化而变化，所以我们可以放心的使用。
#### 22.1.2 避免指针截断 
说明：指针截断是从32位移植到64位系统时，经常会碰到的问题。
```
int *i = &int_val;
short *w = (short*)((int)i + 2);
```
上面的代码在32位环境下运行是没有问题的，但在64位环境下，发生了地址截断：无法把64位长的数据接到32位的数据空间里面。
上面的代码中可以使用intptr_t类型解决：
```
int *i = &int_val;
short *w = (short*)((intptr_t)i + 2);
```
#### 22.1.3 注意数据类型对齐问题 
说明：需要对结构对齐加以留心，尤其是对于存储在磁盘上的结构体。
在64位系统中，任何拥有int64_t/uint64_t成员的类/结构体将默认被处理为8字节对齐。如果32位和64 位代码共用磁盘上的结构体，需要确保两种体系结构下的结构体的一致对齐。
另外，大多数编译器提供了调整结构体对齐的方案：
gcc 中可使用__attribute__((packed))，MSVC 提供了#pragma pack()和__declspec(align())。
由于各个平台和编译器的不同，所以在不同编译器与平台移植代码时，一定要特别关注编译器关于对齐的参数设置与默认值。因为字节对齐不仅影响性能，而且会导致一些不可预知的问题。
#### 22.1.4 在涉及网络字节序处理时，要注意进行网络字节序与本地字节序的转换 
说明：
小端法(Little-Endian)
低位字节排放在内存的低地址端即起始地址，高位字节排放在内存的高地址端。
大端法(Big-Endian)
高位字节排放在内存的低地址端即起始地址，低位字节排放在内存的高地址端。
不同cpu平台上字节序通常也不一样：
X86、AMD64平台使用小端法、而HP-IA， IBM AIX的CPU采用的是大端法。
而网络字节序是大端法，如常见网络发送的码流。
涉及网络字节需要注意处理网络字节序与本地字节序的转换，即使本地字节序采用的也是大端法，为了程序可移植性，建议也调用转换函数进行转换。
库函数提供了16，32位整型int的网络字节序与本地字节序的转换函数：
htonl, htons, ntohl, ntohs - convert values between host and network byte order
#### 22.1.5 避免无符号数与有符号数的转换 
说明：不同的国际标准(ANSI C/ISO C++等)对隐式转换有符号和无符号类型的规则不同，有可能导致不同的执行结果。
```
unsigned short usNumber = xxx;
long lNum = usNumber;
```
将unsigned short赋值给long需要经过两次类型转换，ANSI标准中没有规定多次类型转换的顺序。大多数编译器(例如VC)在高位优先填充0，按照下面的顺序进行转换：
```
lNum = (long) (unsigned long) usNumber;
```
个别编译器(例如BSD的一些编译器)在高位优先填充1，即使用下面的顺序进行转换：
```
lNum = (long) (signed short) usNumber;
```
如果是后一种转换顺序，并且正好usNumber的高位为1，则首先被转换成一个负数的long，接着转换成unsigned long时就成了很大的数。
usNumber永远不可能为负数，没有必要使用signed修饰。
修改办法是定义lNum的类型为unsigned long，并更改名字为ulNum：
```
unsigned short usNumber = xxx;
unsigned long ulNum = usNumber;
```
尽量避免无符号数与有符号数的转换，特别是长度不同数值的类型转换。请首先考虑设计上是否需要这种转换。
#### 22.1.6 创建64 位常量时使用LL 或ULL 作为后缀 
说明：指定LL或ULL后缀说明，能让代码更加清晰。
```
int64_t my_value = 0x123456789LL;
uint64_t my_mask = 3ULL << 48;
```
尤其是在>>操作时，无符号与有符号有很大差异的，如果操作数是无符号数，则右移操作符>>，从左边开始插入0， 否则插入符号位的拷贝或者插入0 ，这由编译器决定。
#### 22.1.7 区分sizeof(void *)和sizeof(int)
说明：64位下sizeof(void *) != sizeof(int)，而在32位下是相同的。
如果需要一个指针大小的整数请使用intptr_t。
#### 22.1.8 编译器，操作系统相关的代码独立出来  
说明：为了程序的可移植性，建议将编译器，操作系统相关的代码从产品代码中独立出来。
编译器特有的东西，如gcc的编译参数__thread, __attribute__等，如果需要做到支持多个平台，需要封装为宏或函数。
例如gcc的__thread对应的VC开关为__declspec(thread)
__thread int number;
__declspec(thread) int number;
均表示number为线程私有存储变量，可采用如下宏来封装：  
```  
#ifdef WIN32
#define THREAD __declspec(thread)
#else
#define THREAD __thread
#endif
THREAD int number;
```  